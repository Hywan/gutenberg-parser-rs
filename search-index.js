var searchIndex = {};
searchIndex["gutenberg_post_parser"] = {"doc":"The Gutenberg post parser.","items":[[5,"root","gutenberg_post_parser","The `root` function represents the axiom of the grammar, i.e. the top rule.",null,{"inputs":[{"name":"input"}],"output":{"generics":["err"],"name":"result"}}],[0,"ast","","The Abstract Syntax Tree (AST), i.e. the output of the parser.",null,null],[4,"Node","gutenberg_post_parser::ast","Represent a node in the AST.",null,null],[13,"Block","","A block is the elementary component of the post format.",0,null],[12,"name","gutenberg_post_parser::ast::Node","The fully-qualified block name, where the left part of the pair represents the namespace, and the right part of the pair represents the block name.",0,null],[12,"attributes","","A block can have attributes, just like an HTML element can have attributes. Attributes are encoded as a JSON string.",0,null],[12,"children","","A block can have inner blocks or phrases.",0,null],[13,"Phrase","gutenberg_post_parser::ast","Anything that is not a block.",0,null],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"combinators","gutenberg_post_parser","Additional combinators specifically tailored for this parser.",null,null],[5,"fold_into_vector","gutenberg_post_parser::combinators","",null,{"inputs":[{"name":"vec"},{"name":"i"}],"output":{"name":"vec"}}],[0,"parser","gutenberg_post_parser","The Gutenberg post parser.",null,null],[5,"block_list","gutenberg_post_parser::parser","Axiom of the grammar: Recognize a list of blocks.",null,{"inputs":[{"name":"input"}],"output":{"generics":["input","vec","u32"],"name":"iresult"}}],[5,"phrase","","Recognize a phrase.",null,{"inputs":[{"name":"input"}],"output":{"generics":["input","node","u32"],"name":"iresult"}}],[5,"block","","Recognize a block.",null,{"inputs":[{"name":"input"}],"output":{"generics":["input","node","u32"],"name":"iresult"}}],[5,"block_name","","Recognize a fully-qualified block name.",null,{"inputs":[{"name":"input"}],"output":{"generics":["input","u32"],"name":"iresult"}}],[5,"namespaced_block_name","","Recognize a namespaced block name.",null,{"inputs":[{"name":"input"}],"output":{"generics":["input","u32"],"name":"iresult"}}],[5,"core_block_name","","Recognize a globally-namespaced block name.",null,{"inputs":[{"name":"input"}],"output":{"generics":["input","u32"],"name":"iresult"}}],[5,"block_name_part","","Recognize a block name part.",null,null],[5,"block_attributes","","Recognize block attributes.",null,null],[5,"whitespaces","","Recognize whitespaces.",null,null],[6,"InputElement","gutenberg_post_parser","Represent the type of a parser input element. See `Input` for more information.",null,null],[6,"Input","","Represent the type of a parser input.",null,null],[14,"take_till_terminated","","`take_till_terminated(S, C)` is like `take_till` from but with a lookahead combinator `C`.",null,null],[14,"fold_into_vector_many0","","`fold_into_vector_many0!(I -> IResult<I,O>, R) => I -> IResult<I, R>` is a wrapper around `fold_many0!` specifically designed for vectors.",null,null]],"paths":[[4,"Node"]]};
searchIndex["memchr"] = {"doc":"This crate defines two functions, `memchr` and `memrchr`, which expose a safe interface to the corresponding functions in `libc`.","items":[[3,"Memchr","memchr","An iterator for memchr",null,null],[3,"Memchr2","","An iterator for Memchr2",null,null],[3,"Memchr3","","An iterator for Memchr3",null,null],[5,"memchr","","A safe interface to `memchr`.",null,null],[5,"memrchr","","A safe interface to `memrchr`.",null,null],[5,"memchr2","","Like `memchr`, but searches for two bytes instead of one.",null,null],[5,"memchr3","","Like `memchr`, but searches for three bytes instead of one.",null,null],[11,"new","","Creates a new iterator that yields all positions of needle in haystack.",0,null],[11,"next","","",0,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"size_hint","","",0,null],[11,"next_back","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Creates a new iterator that yields all positions of needle in haystack.",1,null],[11,"next","","",1,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"size_hint","","",1,null],[11,"new","","Create a new Memchr2 that's initalized to zero with a haystack",2,null],[11,"next","","",2,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"size_hint","","",2,null]],"paths":[[3,"Memchr"],[3,"Memchr2"],[3,"Memchr3"]]};
searchIndex["nom"] = {"doc":"nom, eating data byte by byte","items":[[4,"CompareResult","nom","indicates wether a comparison was successful, an error, or if more data was needed",null,null],[13,"Ok","","",0,null],[13,"Incomplete","","",0,null],[13,"Error","","",0,null],[4,"ErrorKind","","indicates which parser returned an error",null,null],[13,"Custom","","",1,null],[13,"Tag","","",1,null],[13,"MapRes","","",1,null],[13,"MapOpt","","",1,null],[13,"Alt","","",1,null],[13,"IsNot","","",1,null],[13,"IsA","","",1,null],[13,"SeparatedList","","",1,null],[13,"SeparatedNonEmptyList","","",1,null],[13,"Many0","","",1,null],[13,"Many1","","",1,null],[13,"ManyTill","","",1,null],[13,"Count","","",1,null],[13,"TakeUntilAndConsume","","",1,null],[13,"TakeUntil","","",1,null],[13,"TakeUntilEitherAndConsume","","",1,null],[13,"TakeUntilEither","","",1,null],[13,"LengthValue","","",1,null],[13,"TagClosure","","",1,null],[13,"Alpha","","",1,null],[13,"Digit","","",1,null],[13,"HexDigit","","",1,null],[13,"OctDigit","","",1,null],[13,"AlphaNumeric","","",1,null],[13,"Space","","",1,null],[13,"MultiSpace","","",1,null],[13,"LengthValueFn","","",1,null],[13,"Eof","","",1,null],[13,"ExprOpt","","",1,null],[13,"ExprRes","","",1,null],[13,"CondReduce","","",1,null],[13,"Switch","","",1,null],[13,"TagBits","","",1,null],[13,"OneOf","","",1,null],[13,"NoneOf","","",1,null],[13,"Char","","",1,null],[13,"CrLf","","",1,null],[13,"RegexpMatch","","",1,null],[13,"RegexpMatches","","",1,null],[13,"RegexpFind","","",1,null],[13,"RegexpCapture","","",1,null],[13,"RegexpCaptures","","",1,null],[13,"TakeWhile1","","",1,null],[13,"Complete","","",1,null],[13,"Fix","","",1,null],[13,"Escaped","","",1,null],[13,"EscapedTransform","","",1,null],[13,"TagStr","","",1,null],[13,"IsNotStr","","",1,null],[13,"IsAStr","","",1,null],[13,"TakeWhile1Str","","",1,null],[13,"NonEmpty","","",1,null],[13,"ManyMN","","",1,null],[13,"TakeUntilAndConsumeStr","","",1,null],[13,"TakeUntilStr","","",1,null],[13,"Not","","",1,null],[13,"Permutation","","",1,null],[13,"Verify","","",1,null],[13,"TakeTill1","","",1,null],[13,"TakeUntilAndConsume1","","",1,null],[13,"TakeWhileMN","","",1,null],[4,"Needed","","Contains information on needed data if a parser returned `Incomplete`",null,null],[13,"Unknown","","needs more data, but we do not know how much",2,null],[13,"Size","","contains the required data size",2,null],[4,"Err","","The `Err` enum indicates the parser was not successful",null,null],[13,"Incomplete","","There was not enough data",3,null],[13,"Error","","The parser had an error (recoverable)",3,null],[13,"Failure","","The parser had an unrecoverable error: we got to the right branch and we know other branches won't work, so backtrack as fast as possible",3,null],[4,"Endianness","","Configurable endianness",null,null],[13,"Big","","",4,null],[13,"Little","","",4,null],[5,"need_more","","",null,{"inputs":[{"name":"i"},{"name":"needed"}],"output":{"name":"iresult"}}],[5,"need_more_err","","",null,{"inputs":[{"name":"i"},{"name":"needed"},{"name":"errorkind"}],"output":{"name":"iresult"}}],[5,"slice_to_offsets","","",null,null],[5,"code_from_offset","","",null,null],[5,"reset_color","","",null,{"inputs":[{"name":"vec"}],"output":null}],[5,"write_color","","",null,{"inputs":[{"name":"vec"},{"name":"u8"}],"output":null}],[5,"error_to_u32","","",null,{"inputs":[{"name":"errorkind"}],"output":{"name":"u32"}}],[5,"newline","","Matches a newline character '\\n'",null,null],[5,"tab","","Matches a tab character '\\t'",null,null],[5,"anychar","","matches one byte as a character. Note that the input type will accept a `str`, but not a `&[u8]`, unlike many other nom parsers.",null,{"inputs":[{"name":"t"}],"output":{"generics":["char"],"name":"iresult"}}],[5,"tag_cl","","",null,null],[5,"begin","","",null,null],[5,"crlf","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"not_line_ending","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"line_ending","","Recognizes an end of line (both '\\n' and '\\r\\n')",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"eol","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"is_alphabetic","","Tests if byte is ASCII alphabetic: A-Z, a-z",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_digit","","Tests if byte is ASCII digit: 0-9",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_hex_digit","","Tests if byte is ASCII hex digit: 0-9, A-F, a-f",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_oct_digit","","Tests if byte is ASCII octal digit: 0-7",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_space","","Tests if byte is ASCII space or tab",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"alpha","","Recognizes one or more lowercase and uppercase alphabetic characters: a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"generics":["u32"],"name":"iresult"}}],[5,"alpha0","","Recognizes zero or more lowercase and uppercase alphabetic characters: a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"generics":["u32"],"name":"iresult"}}],[5,"alpha1","","Recognizes one or more lowercase and uppercase alphabetic characters: a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"generics":["u32"],"name":"iresult"}}],[5,"digit","","Recognizes one or more numerical characters: 0-9",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"digit0","","Recognizes zero or more numerical characters: 0-9",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"digit1","","Recognizes one or more numerical characters: 0-9",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"hex_digit","","Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"hex_digit0","","Recognizes zero or more hexadecimal numerical characters: 0-9, A-F, a-f",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"hex_digit1","","Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"oct_digit","","Recognizes one or more octal characters: 0-7",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"oct_digit0","","Recognizes zero or more octal characters: 0-7",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"oct_digit1","","Recognizes one or more octal characters: 0-7",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"alphanumeric","","Recognizes one or more numerical and alphabetic characters: 0-9a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"alphanumeric0","","Recognizes zero or more numerical and alphabetic characters: 0-9a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"alphanumeric1","","Recognizes one or more numerical and alphabetic characters: 0-9a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"space","","Recognizes one or more spaces and tabs",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"space0","","Recognizes zero or more spaces and tabs",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"space1","","Recognizes one or more spaces and tabs",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"multispace","","Recognizes one or more spaces, tabs, carriage returns and line feeds",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"multispace0","","Recognizes zero or more spaces, tabs, carriage returns and line feeds",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"multispace1","","Recognizes one or more spaces, tabs, carriage returns and line feeds",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"sized_buffer","","",null,null],[5,"be_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"be_u16","","Recognizes big endian unsigned 2 bytes integer",null,null],[5,"be_u24","","Recognizes big endian unsigned 3 byte integer",null,null],[5,"be_u32","","Recognizes big endian unsigned 4 bytes integer",null,null],[5,"be_u64","","Recognizes big endian unsigned 8 bytes integer",null,null],[5,"be_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"be_i16","","Recognizes big endian signed 2 bytes integer",null,null],[5,"be_i24","","Recognizes big endian signed 3 bytes integer",null,null],[5,"be_i32","","Recognizes big endian signed 4 bytes integer",null,null],[5,"be_i64","","Recognizes big endian signed 8 bytes integer",null,null],[5,"le_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"le_u16","","Recognizes little endian unsigned 2 bytes integer",null,null],[5,"le_u24","","Recognizes little endian unsigned 3 byte integer",null,null],[5,"le_u32","","Recognizes little endian unsigned 4 bytes integer",null,null],[5,"le_u64","","Recognizes little endian unsigned 8 bytes integer",null,null],[5,"le_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"le_i16","","Recognizes little endian signed 2 bytes integer",null,null],[5,"le_i24","","Recognizes little endian signed 3 bytes integer",null,null],[5,"le_i32","","Recognizes little endian signed 4 bytes integer",null,null],[5,"le_i64","","Recognizes little endian signed 8 bytes integer",null,null],[5,"be_f32","","Recognizes big endian 4 bytes floating point number",null,null],[5,"be_f64","","Recognizes big endian 8 bytes floating point number",null,null],[5,"le_f32","","Recognizes little endian 4 bytes floating point number",null,null],[5,"le_f64","","Recognizes little endian 8 bytes floating point number",null,null],[5,"hex_u32","","Recognizes a hex-encoded integer",null,null],[5,"non_empty","","Recognizes non empty buffers",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"rest","","Return the remaining input.",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"rest_s","","Return the remaining input, for strings.",null,{"inputs":[{"name":"str"}],"output":{"generics":["str","str"],"name":"iresult"}}],[5,"recognize_float","","",null,{"inputs":[{"name":"t"}],"output":{"generics":["u32"],"name":"iresult"}}],[5,"float","","Recognizes floating point number in a byte string and returns a f32",null,null],[5,"float_s","","Recognizes floating point number in a string and returns a f32",null,{"inputs":[{"name":"str"}],"output":{"generics":["str","f32"],"name":"iresult"}}],[5,"double","","Recognizes floating point number in a byte string and returns a f64",null,null],[5,"double_s","","Recognizes floating point number in a string and returns a f64",null,{"inputs":[{"name":"str"}],"output":{"generics":["str","f64"],"name":"iresult"}}],[0,"lib","","Lib module to re-export everything needed from `std` or `core`/`alloc`. This is how `serde` does it, albeit there it is not public.",null,null],[0,"std","nom::lib","`std` facade allowing `std`/`core` to be interchangeable. Reexports `alloc` crate optionally, as well as `core` or `std`",null,null],[0,"boxed","nom::lib::std","A pointer type for heap allocation.",null,null],[3,"Box","nom::lib::std::boxed","A pointer type for heap allocation.",null,null],[8,"FnBox","","`FnBox` is a version of the `FnOnce` intended for use with boxed closure objects. The idea is that where one would normally store a `Box<FnOnce()>` in a data structure, you should use `Box<FnBox()>`. The two traits behave essentially the same, except that a `FnBox` closure can only be called if it is boxed. (Note that `FnBox` may be deprecated in the future if `Box<FnOnce()>` closures become directly usable.)",null,null],[16,"Output","","",5,null],[10,"call_box","","",5,null],[3,"PinBox","","A pinned, heap allocated reference.",null,null],[0,"string","nom::lib::std","A UTF-8 encoded, growable string.",null,null],[3,"String","nom::lib::std::string","A UTF-8 encoded, growable string.",null,null],[3,"FromUtf8Error","","A possible error value when converting a `String` from a UTF-8 byte vector.",null,null],[3,"FromUtf16Error","","A possible error value when converting a `String` from a UTF-16 byte slice.",null,null],[4,"ParseError","","An error when parsing a `String`.",null,null],[8,"ToString","","A trait for converting a value to a `String`.",null,null],[10,"to_string","","Converts the given value to a `String`.",6,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[3,"Drain","","A draining iterator for `String`.",null,null],[0,"vec","nom::lib::std","A contiguous growable array type with heap-allocated contents, written `Vec<T>`.",null,null],[3,"Vec","nom::lib::std::vec","A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.",null,null],[3,"IntoIter","","An iterator that moves out of a vector.",null,null],[3,"Drain","","A draining iterator for `Vec<T>`.",null,null],[3,"Splice","","A splicing iterator for `Vec`.",null,null],[3,"DrainFilter","","An iterator produced by calling `drain_filter` on Vec.",null,null],[0,"cmp","nom::lib::std","Functionality for ordering and comparison.",null,null],[8,"PartialEq","nom::lib::std::cmp","Trait for equality comparisons which are partial equivalence relations.",null,null],[10,"eq","","This method tests for `self` and `other` values to be equal, and is used by `==`.",7,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"ne","","This method tests for `!=`.",7,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[8,"Eq","","Trait for equality comparisons which are equivalence relations.",null,null],[4,"Ordering","","An `Ordering` is the result of a comparison between two values.",null,null],[13,"Less","","An ordering where a compared value is less [than another].",8,null],[13,"Equal","","An ordering where a compared value is equal [to another].",8,null],[13,"Greater","","An ordering where a compared value is greater [than another].",8,null],[3,"Reverse","","A helper struct for reverse ordering.",null,null],[12,"0","","",9,null],[8,"Ord","","Trait for types that form a total order.",null,null],[10,"cmp","","This method returns an `Ordering` between `self` and `other`.",10,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"max","","Compares and returns the maximum of two values.",10,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"min","","Compares and returns the minimum of two values.",10,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"PartialOrd","","Trait for values that can be compared for a sort-order.",null,null],[10,"partial_cmp","","This method returns an ordering between `self` and `other` values if one exists.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","This method tests less than (for `self` and `other`) and is used by the `<` operator.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"le","","This method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"gt","","This method tests greater than (for `self` and `other`) and is used by the `>` operator.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"ge","","This method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[5,"min","","Compares and returns the minimum of two values.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"max","","Compares and returns the maximum of two values.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[0,"convert","nom::lib::std","Traits for conversions between types.",null,null],[8,"AsRef","nom::lib::std::convert","A cheap reference-to-reference conversion. Used to convert a value to a reference value within generic code.",null,null],[10,"as_ref","","Performs the conversion.",12,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"AsMut","","A cheap, mutable reference-to-mutable reference conversion.",null,null],[10,"as_mut","","Performs the conversion.",13,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"Into","","A conversion that consumes `self`, which may or may not be expensive. The reciprocal of [`From`][From].",null,null],[10,"into","","Performs the conversion.",14,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"From","","Simple and safe type conversions in to `Self`. It is the reciprocal of `Into`.",null,null],[10,"from","","Performs the conversion.",15,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[8,"TryInto","","An attempted conversion that consumes `self`, which may or may not be expensive.",null,null],[16,"Error","","The type returned in the event of a conversion error.",16,null],[10,"try_into","","Performs the conversion.",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[8,"TryFrom","","Attempt to construct `Self` via a conversion.",null,null],[16,"Error","","The type returned in the event of a conversion error.",17,null],[10,"try_from","","Performs the conversion.",17,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[0,"fmt","nom::lib::std","Utilities for formatting and printing strings.",null,null],[4,"Alignment","nom::lib::std::fmt","Possible alignments returned by `Formatter::align`",null,null],[13,"Left","","Indication that contents should be left-aligned.",18,null],[13,"Right","","Indication that contents should be right-aligned.",18,null],[13,"Center","","Indication that contents should be center-aligned.",18,null],[13,"Unknown","","No alignment was requested.",18,null],[6,"Result","","The type returned by formatter methods.",null,null],[3,"Error","","The error type which is returned from formatting a message into a stream.",null,null],[8,"Write","","A collection of methods that are required to format a message into a stream.",null,null],[10,"write_str","","Writes a slice of bytes into this writer, returning whether the write succeeded.",19,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_char","","Writes a [`char`] into this writer, returning whether the write succeeded.",19,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_fmt","","Glue for usage of the [`write!`] macro with implementors of this trait.",19,{"inputs":[{"name":"self"},{"name":"arguments"}],"output":{"generics":["error"],"name":"result"}}],[3,"Formatter","","A struct to represent both where to emit formatting strings to and how they should be formatted. A mutable version of this is passed to all formatting traits.",null,null],[3,"Arguments","","This structure represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.",null,null],[8,"Debug","","`?` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"Display","","Format trait for an empty format, `{}`.",null,null],[10,"fmt","","Formats the value using the given formatter.",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"Octal","","`o` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"Binary","","`b` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"LowerHex","","`x` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"UpperHex","","`X` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"Pointer","","`p` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"LowerExp","","`e` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"UpperExp","","`E` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[5,"write","","The `write` function takes an output stream, and an `Arguments` struct that can be precompiled with the `format_args!` macro.",null,{"inputs":[{"name":"write"},{"name":"arguments"}],"output":{"generics":["error"],"name":"result"}}],[3,"DebugMap","","A struct to help with `fmt::Debug` implementations.",null,null],[3,"DebugStruct","","A struct to help with `fmt::Debug` implementations.",null,null],[3,"DebugList","","A struct to help with `fmt::Debug` implementations.",null,null],[3,"DebugSet","","A struct to help with `fmt::Debug` implementations.",null,null],[3,"DebugTuple","","A struct to help with `fmt::Debug` implementations.",null,null],[0,"iter","nom::lib::std","Composable external iteration.",null,null],[3,"Rev","nom::lib::std::iter","A double-ended iterator with the direction inverted.",null,null],[3,"Cloned","","An iterator that clones the elements of an underlying iterator.",null,null],[3,"Cycle","","An iterator that repeats endlessly.",null,null],[3,"StepBy","","An iterator for stepping iterators by a custom amount.",null,null],[3,"Chain","","An iterator that strings two iterators together.",null,null],[3,"Zip","","An iterator that iterates two other iterators simultaneously.",null,null],[3,"Map","","An iterator that maps the values of `iter` with `f`.",null,null],[3,"Filter","","An iterator that filters the elements of `iter` with `predicate`.",null,null],[3,"FilterMap","","An iterator that uses `f` to both filter and map elements from `iter`.",null,null],[3,"Enumerate","","An iterator that yields the current count and the element during iteration.",null,null],[3,"Peekable","","An iterator with a `peek()` that returns an optional reference to the next element.",null,null],[3,"SkipWhile","","An iterator that rejects elements while `predicate` is true.",null,null],[3,"TakeWhile","","An iterator that only accepts elements while `predicate` is true.",null,null],[3,"Skip","","An iterator that skips over `n` elements of `iter`.",null,null],[3,"Take","","An iterator that only iterates over the first `n` iterations of `iter`.",null,null],[3,"Scan","","An iterator to maintain state while iterating another iterator.",null,null],[3,"FlatMap","","An iterator that maps each element to an iterator, and yields the elements of the produced iterators.",null,null],[3,"Flatten","","An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.",null,null],[3,"Fuse","","An iterator that yields `None` forever after the underlying iterator yields `None` once.",null,null],[3,"Inspect","","An iterator that calls a function with a reference to each element before yielding it.",null,null],[3,"Repeat","","An iterator that repeats an element endlessly.",null,null],[8,"Extend","","Extend a collection with the contents of an iterator.",null,null],[10,"extend","","Extends a collection with the contents of an iterator.",29,null],[3,"Empty","","An iterator that yields nothing.",null,null],[8,"Sum","","Trait to represent types that can be created by summing up an iterator.",null,null],[10,"sum","","Method which takes an iterator and generates `Self` from the elements by \"summing up\" the items.",30,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[5,"repeat_with","","Creates a new iterator that repeats elements of type `A` endlessly by applying the provided closure, the repeater, `F: FnMut() -> A`.",null,{"inputs":[{"name":"f"}],"output":{"name":"repeatwith"}}],[8,"Iterator","","An interface for dealing with iterators.",null,null],[16,"Item","","The type of the elements being iterated over.",31,null],[10,"next","","Advances the iterator and returns the next value.",31,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","Returns the bounds on the remaining length of the iterator.",31,null],[11,"count","","Consumes the iterator, counting the number of iterations and returning it.",31,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","Consumes the iterator, returning the last element.",31,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","Returns the `n`th element of the iterator.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"step_by","","Creates an iterator starting at the same point, but stepping by the given amount at each iteration.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"stepby"}}],[11,"chain","","Takes two iterators and creates a new iterator over both in sequence.",31,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"chain"}}],[11,"zip","","'Zips up' two iterators into a single iterator of pairs.",31,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"zip"}}],[11,"map","","Takes a closure and creates an iterator which calls that closure on each element.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"map"}}],[11,"for_each","","Calls a closure on each element of an iterator.",31,null],[11,"filter","","Creates an iterator which uses a closure to determine if an element should be yielded.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"filter"}}],[11,"filter_map","","Creates an iterator that both filters and maps.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"filtermap"}}],[11,"enumerate","","Creates an iterator which gives the current iteration count as well as the next value.",31,{"inputs":[{"name":"self"}],"output":{"name":"enumerate"}}],[11,"peekable","","Creates an iterator which can use `peek` to look at the next element of the iterator without consuming it.",31,{"inputs":[{"name":"self"}],"output":{"name":"peekable"}}],[11,"skip_while","","Creates an iterator that [`skip`]s elements based on a predicate.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"skipwhile"}}],[11,"take_while","","Creates an iterator that yields elements based on a predicate.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"takewhile"}}],[11,"skip","","Creates an iterator that skips the first `n` elements.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"skip"}}],[11,"take","","Creates an iterator that yields its first `n` elements.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"take"}}],[11,"scan","","An iterator adaptor similar to [`fold`] that holds internal state and produces a new iterator.",31,{"inputs":[{"name":"self"},{"name":"st"},{"name":"f"}],"output":{"name":"scan"}}],[11,"flat_map","","Creates an iterator that works like map, but flattens nested structure.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"flatmap"}}],[11,"flatten","","Creates an iterator that flattens nested structure.",31,{"inputs":[{"name":"self"}],"output":{"name":"flatten"}}],[11,"fuse","","Creates an iterator which ends after the first [`None`].",31,{"inputs":[{"name":"self"}],"output":{"name":"fuse"}}],[11,"inspect","","Do something with each element of an iterator, passing the value on.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"inspect"}}],[11,"by_ref","","Borrows an iterator, rather than consuming it.",31,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"collect","","Transforms an iterator into a collection.",31,{"inputs":[{"name":"self"}],"output":{"name":"b"}}],[11,"partition","","Consumes an iterator, creating two collections from it.",31,null],[11,"try_fold","","An iterator method that applies a function as long as it returns successfully, producing a single, final value.",31,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"try_for_each","","An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","An iterator method that applies a function, producing a single, final value.",31,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"b"}}],[11,"all","","Tests if every element of the iterator matches a predicate.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"any","","Tests if any element of the iterator matches a predicate.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"find","","Searches for an element of an iterator that satisfies a predicate.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"find_map","","Applies function to the elements of iterator and returns the first non-none result.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"position","","Searches for an element in an iterator, returning its index.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"rposition","","Searches for an element in an iterator from the right, returning its index.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"max","","Returns the maximum element of an iterator.",31,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"min","","Returns the minimum element of an iterator.",31,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"max_by_key","","Returns the element that gives the maximum value from the specified function.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"max_by","","Returns the element that gives the maximum value with respect to the specified comparison function.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"min_by_key","","Returns the element that gives the minimum value from the specified function.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"min_by","","Returns the element that gives the minimum value with respect to the specified comparison function.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"rev","","Reverses an iterator's direction.",31,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"unzip","","Converts an iterator of pairs into a pair of containers.",31,null],[11,"cloned","","Creates an iterator which [`clone`]s all of its elements.",31,{"inputs":[{"name":"self"}],"output":{"name":"cloned"}}],[11,"cycle","","Repeats an iterator endlessly.",31,{"inputs":[{"name":"self"}],"output":{"name":"cycle"}}],[11,"sum","","Sums the elements of an iterator.",31,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[11,"product","","Iterates over the entire iterator, multiplying all the elements",31,{"inputs":[{"name":"self"}],"output":{"name":"p"}}],[11,"cmp","","Lexicographically compares the elements of this `Iterator` with those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","Lexicographically compares the elements of this `Iterator` with those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"eq","","Determines if the elements of this `Iterator` are equal to those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"ne","","Determines if the elements of this `Iterator` are unequal to those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"lt","","Determines if the elements of this `Iterator` are lexicographically less than those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"le","","Determines if the elements of this `Iterator` are lexicographically less or equal to those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"gt","","Determines if the elements of this `Iterator` are lexicographically greater than those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"ge","","Determines if the elements of this `Iterator` are lexicographically greater than or equal to those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[8,"TrustedLen","","An iterator that reports an accurate length using size_hint.",null,null],[5,"empty","","Creates an iterator that yields nothing.",null,{"inputs":[],"output":{"name":"empty"}}],[3,"Once","","An iterator that yields an element exactly once.",null,null],[3,"RepeatWith","","An iterator that repeats elements of type `A` endlessly by applying the provided closure `F: FnMut() -> A`.",null,null],[8,"FusedIterator","","An iterator that always continues to yield `None` when exhausted.",null,null],[8,"IntoIterator","","Conversion into an `Iterator`.",null,null],[16,"Item","","The type of the elements being iterated over.",32,null],[16,"IntoIter","","Which kind of iterator are we turning this into?",32,null],[10,"into_iter","","Creates an iterator from a value.",32,null],[8,"Step","","Objects that can be stepped over in both directions.",null,null],[10,"steps_between","","Returns the number of steps between two step objects. The count is inclusive of `start` and exclusive of `end`.",33,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[10,"replace_one","","Replaces this step with `1`, returning itself",33,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"replace_zero","","Replaces this step with `0`, returning itself",33,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"add_one","","Adds one to this step, returning the result",33,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"sub_one","","Subtracts one to this step, returning the result",33,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"add_usize","","Add an usize, returning None on overflow",33,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[5,"repeat","","Creates a new iterator that endlessly repeats a single element.",null,{"inputs":[{"name":"t"}],"output":{"name":"repeat"}}],[8,"FromIterator","","Conversion from an `Iterator`.",null,null],[10,"from_iter","","Creates a value from an iterator.",34,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[8,"ExactSizeIterator","","An iterator that knows its exact length.",null,null],[11,"len","","Returns the exact number of times the iterator will iterate.",35,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns whether the iterator is empty.",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[5,"once","","Creates an iterator that yields an element exactly once.",null,{"inputs":[{"name":"t"}],"output":{"name":"once"}}],[8,"DoubleEndedIterator","","An iterator able to yield elements from both ends.",null,null],[10,"next_back","","Removes and returns an element from the end of the iterator.",36,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","This is the reverse version of [`try_fold()`]: it takes elements starting from the back of the iterator.",36,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","An iterator method that reduces the iterator's elements to a single, final value, starting from the back.",36,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"b"}}],[11,"rfind","","Searches for an element of an iterator from the back that satisfies a predicate.",36,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[8,"Product","","Trait to represent types that can be created by multiplying elements of an iterator.",null,null],[10,"product","","Method which takes an iterator and generates `Self` from the elements by multiplying the items.",37,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[0,"mem","nom::lib::std","Basic functions for dealing with memory.",null,null],[5,"forget","nom::lib::std::mem","Leaks a value: takes ownership and \"forgets\" about the value without running its destructor.",null,null],[5,"size_of","","Returns the size of a type in bytes.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"size_of_val","","Returns the size of the pointed-to value in bytes.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"min_align_of","","Returns the [ABI]-required minimum alignment of a type.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"min_align_of_val","","Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"align_of","","Returns the [ABI]-required minimum alignment of a type.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"align_of_val","","Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"needs_drop","","Returns whether dropping values of type `T` matters.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"zeroed","","Creates a value whose bytes are all zero.",null,{"inputs":[],"output":{"name":"t"}}],[5,"uninitialized","","Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type `T`, while doing nothing at all.",null,{"inputs":[],"output":{"name":"t"}}],[5,"swap","","Swaps the values at two mutable locations, without deinitializing either one.",null,null],[5,"replace","","Replaces the value at a mutable location with a new one, returning the old value, without deinitializing either one.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"drop","","Disposes of a value.",null,null],[5,"transmute_copy","","Interprets `src` as having type `&U`, and then reads `src` without moving the contained value.",null,{"inputs":[{"name":"t"}],"output":{"name":"u"}}],[3,"Discriminant","","Opaque type representing the discriminant of an enum.",null,null],[5,"discriminant","","Returns a value uniquely identifying the enum variant in `v`.",null,{"inputs":[{"name":"t"}],"output":{"name":"discriminant"}}],[19,"ManuallyDrop","","A wrapper to inhibit compiler from automatically calling `T`’s destructor.",null,null],[3,"PinMut","","A pinned reference.",null,null],[5,"transmute","","Reinterprets the bits of a value of one type as another type.",null,{"inputs":[{"name":"t"}],"output":{"name":"u"}}],[0,"ops","nom::lib::std","Overloadable operators.",null,null],[8,"Drop","nom::lib::std::ops","Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.",null,null],[10,"drop","","Executes the destructor for this type.",38,null],[8,"RangeBounds","","`RangeBounds` is implemented by Rust's built-in range types, produced by range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[10,"start","","Start index bound.",39,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[10,"end","","End index bound.",39,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",39,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"bool"}}],[3,"RangeTo","","A range only bounded exclusively above (`..end`).",null,null],[12,"end","","The upper bound of the range (exclusive).",40,null],[8,"BitAndAssign","","The bitwise AND assignment operator `&=`.",null,null],[10,"bitand_assign","","Performs the `&=` operation.",41,null],[8,"Mul","","The multiplication operator `*`.",null,null],[16,"Output","","The resulting type after applying the `*` operator.",42,null],[10,"mul","","Performs the `*` operation.",42,null],[8,"Try","","A trait for customizing the behavior of the `?` operator.",null,null],[16,"Ok","","The type of this value when viewed as successful.",43,null],[16,"Error","","The type of this value when viewed as failed.",43,null],[10,"into_result","","Applies the \"?\" operator. A return of `Ok(t)` means that the execution should continue normally, and the result of `?` is the value `t`. A return of `Err(e)` means that execution should branch to the innermost enclosing `catch`, or return from the function.",43,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"from_error","","Wrap an error value to construct the composite result. For example, `Result::Err(x)` and `Result::from_error(x)` are equivalent.",43,null],[10,"from_ok","","Wrap an OK value to construct the composite result. For example, `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.",43,null],[8,"Index","","Used for indexing operations (`container[index]`) in immutable contexts.",null,null],[16,"Output","","The returned type after indexing.",44,null],[10,"index","","Performs the indexing (`container[index]`) operation.",44,null],[8,"Generator","","The trait implemented by builtin generator types.",null,null],[16,"Yield","","The type of value this generator yields.",45,null],[16,"Return","","The type of value this generator returns.",45,null],[10,"resume","","Resumes the execution of this generator.",45,{"inputs":[{"name":"self"}],"output":{"name":"generatorstate"}}],[8,"DerefMut","","Used for mutable dereferencing operations, like in `*v = 1;`.",null,null],[10,"deref_mut","","Mutably dereferences the value.",46,null],[8,"FnOnce","","The version of the call operator that takes a by-value receiver.",null,null],[16,"Output","","The returned type after the call operator is used.",47,null],[10,"call_once","","Performs the call operation.",47,null],[3,"RangeFull","","An unbounded range (`..`).",null,null],[8,"BitOr","","The bitwise OR operator `|`.",null,null],[16,"Output","","The resulting type after applying the `|` operator.",48,null],[10,"bitor","","Performs the `|` operation.",48,null],[8,"RemAssign","","The remainder assignment operator `%=`.",null,null],[10,"rem_assign","","Performs the `%=` operation.",49,null],[3,"RangeToInclusive","","A range only bounded inclusively above (`..=end`).",null,null],[12,"end","","The upper bound of the range (inclusive)",50,null],[8,"BitAnd","","The bitwise AND operator `&`.",null,null],[16,"Output","","The resulting type after applying the `&` operator.",51,null],[10,"bitand","","Performs the `&` operation.",51,null],[8,"ShlAssign","","The left shift assignment operator `<<=`.",null,null],[10,"shl_assign","","Performs the `<<=` operation.",52,null],[8,"Neg","","The unary negation operator `-`.",null,null],[16,"Output","","The resulting type after applying the `-` operator.",53,null],[10,"neg","","Performs the unary `-` operation.",53,null],[8,"ShrAssign","","The right shift assignment operator `>>=`.",null,null],[10,"shr_assign","","Performs the `>>=` operation.",54,null],[8,"DivAssign","","The division assignment operator `/=`.",null,null],[10,"div_assign","","Performs the `/=` operation.",55,null],[8,"Add","","The addition operator `+`.",null,null],[16,"Output","","The resulting type after applying the `+` operator.",56,null],[10,"add","","Performs the `+` operation.",56,null],[3,"RangeFrom","","A range only bounded inclusively below (`start..`).",null,null],[12,"start","","The lower bound of the range (inclusive).",57,null],[8,"Shl","","The left shift operator `<<`. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for `_ << _`, setting the result type for integer operations to the type of the left-hand-side operand. This means that though `a << b` and `a.shl(b)` are one and the same from an evaluation standpoint, they are different when it comes to type inference.",null,null],[16,"Output","","The resulting type after applying the `<<` operator.",58,null],[10,"shl","","Performs the `<<` operation.",58,null],[3,"RangeInclusive","","An range bounded inclusively below and above (`start..=end`).",null,null],[8,"Deref","","Used for immutable dereferencing operations, like `*v`.",null,null],[16,"Target","","The resulting type after dereferencing.",59,null],[10,"deref","","Dereferences the value.",59,null],[8,"MulAssign","","The multiplication assignment operator `*=`.",null,null],[10,"mul_assign","","Performs the `*=` operation.",60,null],[8,"Fn","","The version of the call operator that takes an immutable receiver.",null,null],[10,"call","","Performs the call operation.",61,null],[8,"SubAssign","","The subtraction assignment operator `-=`.",null,null],[10,"sub_assign","","Performs the `-=` operation.",62,null],[8,"BitXor","","The bitwise XOR operator `^`.",null,null],[16,"Output","","The resulting type after applying the `^` operator.",63,null],[10,"bitxor","","Performs the `^` operation.",63,null],[8,"FnMut","","The version of the call operator that takes a mutable receiver.",null,null],[10,"call_mut","","Performs the call operation.",64,null],[8,"Rem","","The remainder operator `%`.",null,null],[16,"Output","","The resulting type after applying the `%` operator.",65,null],[10,"rem","","Performs the `%` operation.",65,null],[8,"Shr","","The right shift operator `>>`. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for `_ >> _`, setting the result type for integer operations to the type of the left-hand-side operand. This means that though `a >> b` and `a.shr(b)` are one and the same from an evaluation standpoint, they are different when it comes to type inference.",null,null],[16,"Output","","The resulting type after applying the `>>` operator.",66,null],[10,"shr","","Performs the `>>` operation.",66,null],[3,"Range","","A (half-open) range bounded inclusively below and exclusively above (`start..end`).",null,null],[12,"start","","The lower bound of the range (inclusive).",67,null],[12,"end","","The upper bound of the range (exclusive).",67,null],[8,"BitXorAssign","","The bitwise XOR assignment operator `^=`.",null,null],[10,"bitxor_assign","","Performs the `^=` operation.",68,null],[8,"Not","","The unary logical negation operator `!`.",null,null],[16,"Output","","The resulting type after applying the `!` operator.",69,null],[10,"not","","Performs the unary `!` operation.",69,null],[8,"AddAssign","","The addition assignment operator `+=`.",null,null],[10,"add_assign","","Performs the `+=` operation.",70,null],[4,"Bound","","An endpoint of a range of keys.",null,null],[13,"Included","","An inclusive bound.",71,null],[13,"Excluded","","An exclusive bound.",71,null],[13,"Unbounded","","An infinite endpoint. Indicates that there is no bound in this direction.",71,null],[8,"Div","","The division operator `/`.",null,null],[16,"Output","","The resulting type after applying the `/` operator.",72,null],[10,"div","","Performs the `/` operation.",72,null],[4,"GeneratorState","","The result of a generator resumption.",null,null],[13,"Yielded","","The generator suspended with a value.",73,null],[13,"Complete","","The generator completed with a return value.",73,null],[8,"CoerceUnsized","","Trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee.",null,null],[8,"IndexMut","","Used for indexing operations (`container[index]`) in mutable contexts.",null,null],[10,"index_mut","","Performs the mutable indexing (`container[index]`) operation.",74,null],[8,"BitOrAssign","","The bitwise OR assignment operator `|=`.",null,null],[10,"bitor_assign","","Performs the `|=` operation.",75,null],[8,"Sub","","The subtraction operator `-`.",null,null],[16,"Output","","The resulting type after applying the `-` operator.",76,null],[10,"sub","","Performs the `-` operation.",76,null],[0,"option","nom::lib::std","Optional values.",null,null],[4,"Option","nom::lib::std::option","The `Option` type. See the module level documentation for more.",null,null],[13,"None","","No value",77,null],[13,"Some","","Some value `T`",77,null],[3,"Iter","","An iterator over a reference to the [`Some`] variant of an [`Option`].",null,null],[3,"IterMut","","An iterator over a mutable reference to the [`Some`] variant of an [`Option`].",null,null],[3,"IntoIter","","An iterator over the value in [`Some`] variant of an [`Option`].",null,null],[3,"NoneError","","The error type that results from applying the try operator (`?`) to a `None` value. If you wish to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.",null,null],[0,"result","nom::lib::std","Error handling with the `Result` type.",null,null],[4,"Result","nom::lib::std::result","`Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).",null,null],[13,"Ok","","Contains the success value",78,null],[13,"Err","","Contains the error value",78,null],[3,"Iter","","An iterator over a reference to the [`Ok`] variant of a [`Result`].",null,null],[3,"IterMut","","An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].",null,null],[3,"IntoIter","","An iterator over the value in a [`Ok`] variant of a [`Result`].",null,null],[0,"slice","nom::lib::std","Slice management and manipulation",null,null],[0,"memchr","nom::lib::std::slice","Pure rust memchr implementation, taken from rust-memchr",null,null],[5,"memchr","nom::lib::std::slice::memchr","Return the first index matching the byte `x` in `text`.",null,null],[5,"memrchr","","Return the last index matching the byte `x` in `text`.",null,null],[8,"SliceIndex","nom::lib::std::slice","A helper trait used for indexing operations.",null,null],[16,"Output","","The output type returned by methods.",79,null],[10,"get","","Returns a shared reference to the output at this location, if in bounds.",79,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[10,"get_mut","","Returns a mutable reference to the output at this location, if in bounds.",79,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[10,"get_unchecked","","Returns a shared reference to the output at this location, without performing any bounds checking.",79,null],[10,"get_unchecked_mut","","Returns a mutable reference to the output at this location, without performing any bounds checking.",79,null],[10,"index","","Returns a shared reference to the output at this location, panicking if out of bounds.",79,null],[10,"index_mut","","Returns a mutable reference to the output at this location, panicking if out of bounds.",79,null],[3,"Iter","","Immutable slice iterator",null,null],[3,"IterMut","","Mutable slice iterator.",null,null],[3,"Split","","An iterator over subslices separated by elements that match a predicate function.",null,null],[3,"SplitMut","","An iterator over the subslices of the vector which are separated by elements that match `pred`.",null,null],[3,"RSplit","","An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.",null,null],[3,"RSplitMut","","An iterator over the subslices of the vector which are separated by elements that match `pred`, starting from the end of the slice.",null,null],[3,"SplitN","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.",null,null],[3,"RSplitN","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.",null,null],[3,"SplitNMut","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.",null,null],[3,"RSplitNMut","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.",null,null],[3,"Windows","","An iterator over overlapping subslices of length `size`.",null,null],[3,"Chunks","","An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a time).",null,null],[3,"ChunksMut","","An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size` elements at a time). When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.",null,null],[3,"ExactChunks","","An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a time).",null,null],[3,"ExactChunksMut","","An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size` elements at a time). When the slice len is not evenly divided by the chunk size, the last up to `chunk_size-1` elements will be omitted.",null,null],[5,"from_raw_parts","","Forms a slice from a pointer and a length.",null,null],[5,"from_raw_parts_mut","","Performs the same functionality as `from_raw_parts`, except that a mutable slice is returned.",null,null],[5,"from_ref","","Converts a reference to T into a slice of length 1 (without copying).",null,null],[5,"from_ref_mut","","Converts a reference to T into a slice of length 1 (without copying).",null,null],[0,"str","nom::lib::std","String manipulation",null,null],[0,"pattern","nom::lib::std::str","The string Pattern API.",null,null],[8,"Pattern","nom::lib::std::str::pattern","A string pattern.",null,null],[16,"Searcher","","Associated searcher for this pattern",80,null],[10,"into_searcher","","Constructs the associated searcher from `self` and the `haystack` to search in.",80,null],[11,"is_contained_in","","Checks whether the pattern matches anywhere in the haystack",80,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"is_prefix_of","","Checks whether the pattern matches at the front of the haystack",80,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"is_suffix_of","","Checks whether the pattern matches at the back of the haystack",80,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[4,"SearchStep","","Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.",null,null],[13,"Match","","Expresses that a match of the pattern has been found at `haystack[a..b]`.",81,null],[13,"Reject","","Expresses that `haystack[a..b]` has been rejected as a possible match of the pattern.",81,null],[13,"Done","","Expresses that every byte of the haystack has been visited, ending the iteration.",81,null],[8,"Searcher","","A searcher for a string pattern.",null,null],[10,"haystack","","Getter for the underlying string to be searched in",82,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[10,"next","","Performs the next search step starting from the front.",82,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","Find the next `Match` result. See `next()`",82,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject","","Find the next `Reject` result. See `next()` and `next_match()`",82,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[8,"ReverseSearcher","","A reverse searcher for a string pattern.",null,null],[10,"next_back","","Performs the next search step starting from the back.",83,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","Find the next `Match` result. See `next_back()`",83,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject_back","","Find the next `Reject` result. See `next_back()`",83,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[8,"DoubleEndedSearcher","","A marker trait to express that a `ReverseSearcher` can be used for a `DoubleEndedIterator` implementation.",null,null],[3,"CharSearcher","","Associated type for `<char as Pattern<'a>>::Searcher`.",null,null],[3,"CharSliceSearcher","","Associated type for `<&[char] as Pattern<'a>>::Searcher`.",null,null],[3,"CharPredicateSearcher","","Associated type for `<F as Pattern<'a>>::Searcher`.",null,null],[3,"StrSearcher","","Associated type for `<&str as Pattern<'a>>::Searcher`.",null,null],[0,"lossy","nom::lib::std::str","",null,null],[3,"Utf8Lossy","nom::lib::std::str::lossy","Lossy UTF-8 string.",null,null],[3,"Utf8LossyChunksIter","","Iterator over lossy UTF-8 string",null,null],[3,"Utf8LossyChunk","","",null,null],[12,"valid","","Sequence of valid chars. Can be empty between broken UTF-8 chars.",84,null],[12,"broken","","Single broken char, empty if none. Empty iff iterator item is last.",84,null],[8,"FromStr","nom::lib::std::str","A trait to abstract the idea of creating a new instance of a type from a string.",null,null],[16,"Err","","The associated error which can be returned from parsing.",85,null],[10,"from_str","","Parses a string `s` to return a value of this type.",85,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[3,"ParseBoolError","","An error returned when parsing a `bool` using [`from_str`] fails",null,null],[3,"Utf8Error","","Errors which can occur when attempting to interpret a sequence of [`u8`] as a string.",null,null],[5,"from_utf8","","Converts a slice of bytes to a string slice.",null,null],[5,"from_utf8_mut","","Converts a mutable slice of bytes to a mutable string slice.",null,null],[5,"from_utf8_unchecked","","Converts a slice of bytes to a string slice without checking that the string contains valid UTF-8.",null,null],[5,"from_utf8_unchecked_mut","","Converts a slice of bytes to a string slice without checking that the string contains valid UTF-8; mutable version.",null,null],[3,"Chars","","An iterator over the [`char`]s of a string slice.",null,null],[5,"next_code_point","","Reads the next code point out of a byte iterator (assuming a UTF-8-like encoding).",null,{"inputs":[{"name":"i"}],"output":{"generics":["u32"],"name":"option"}}],[3,"CharIndices","","An iterator over the [`char`]s of a string slice, and their positions.",null,null],[3,"Bytes","","An iterator over the bytes of a string slice.",null,null],[3,"Split","","Created with the method [`split`].",null,null],[3,"RSplit","","Created with the method [`rsplit`].",null,null],[3,"SplitTerminator","","Created with the method [`split_terminator`].",null,null],[3,"RSplitTerminator","","Created with the method [`rsplit_terminator`].",null,null],[3,"SplitN","","Created with the method [`splitn`].",null,null],[3,"RSplitN","","Created with the method [`rsplitn`].",null,null],[3,"MatchIndices","","Created with the method [`match_indices`].",null,null],[3,"RMatchIndices","","Created with the method [`rmatch_indices`].",null,null],[3,"Matches","","Created with the method [`matches`].",null,null],[3,"RMatches","","Created with the method [`rmatches`].",null,null],[3,"Lines","","An iterator over the lines of a string, as string slices.",null,null],[3,"LinesAny","","Created with the method [`lines_any`].",null,null],[5,"utf8_char_width","","Given a first byte, determines how many bytes are in this UTF-8 character.",null,{"inputs":[{"name":"u8"}],"output":{"name":"usize"}}],[3,"SplitWhitespace","","An iterator over the non-whitespace substrings of a string, separated by any amount of whitespace.",null,null],[3,"EncodeUtf16","","An iterator of [`u16`] over the string encoded as UTF-16.",null,null],[0,"prelude","nom::lib::std","",null,null],[0,"v1","nom::lib::std::prelude","The libcore prelude",null,null],[0,"v1","nom::lib::std::prelude::v1","The core prelude",null,null],[5,"drop","nom::lib::std::prelude::v1::v1","Disposes of a value.",null,null],[8,"Drop","","Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.",null,null],[10,"drop","","Executes the destructor for this type.",38,null],[8,"Extend","","Extend a collection with the contents of an iterator.",null,null],[10,"extend","","Extends a collection with the contents of an iterator.",29,null],[8,"FnOnce","","The version of the call operator that takes a by-value receiver.",null,null],[16,"Output","","The returned type after the call operator is used.",47,null],[10,"call_once","","Performs the call operation.",47,null],[8,"PartialEq","","Trait for equality comparisons which are partial equivalence relations.",null,null],[10,"eq","","This method tests for `self` and `other` values to be equal, and is used by `==`.",7,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"ne","","This method tests for `!=`.",7,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[8,"Iterator","","An interface for dealing with iterators.",null,null],[16,"Item","","The type of the elements being iterated over.",31,null],[10,"next","","Advances the iterator and returns the next value.",31,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","Returns the bounds on the remaining length of the iterator.",31,null],[11,"count","","Consumes the iterator, counting the number of iterations and returning it.",31,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","Consumes the iterator, returning the last element.",31,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","Returns the `n`th element of the iterator.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"step_by","","Creates an iterator starting at the same point, but stepping by the given amount at each iteration.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"stepby"}}],[11,"chain","","Takes two iterators and creates a new iterator over both in sequence.",31,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"chain"}}],[11,"zip","","'Zips up' two iterators into a single iterator of pairs.",31,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"zip"}}],[11,"map","","Takes a closure and creates an iterator which calls that closure on each element.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"map"}}],[11,"for_each","","Calls a closure on each element of an iterator.",31,null],[11,"filter","","Creates an iterator which uses a closure to determine if an element should be yielded.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"filter"}}],[11,"filter_map","","Creates an iterator that both filters and maps.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"filtermap"}}],[11,"enumerate","","Creates an iterator which gives the current iteration count as well as the next value.",31,{"inputs":[{"name":"self"}],"output":{"name":"enumerate"}}],[11,"peekable","","Creates an iterator which can use `peek` to look at the next element of the iterator without consuming it.",31,{"inputs":[{"name":"self"}],"output":{"name":"peekable"}}],[11,"skip_while","","Creates an iterator that [`skip`]s elements based on a predicate.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"skipwhile"}}],[11,"take_while","","Creates an iterator that yields elements based on a predicate.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"takewhile"}}],[11,"skip","","Creates an iterator that skips the first `n` elements.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"skip"}}],[11,"take","","Creates an iterator that yields its first `n` elements.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"take"}}],[11,"scan","","An iterator adaptor similar to [`fold`] that holds internal state and produces a new iterator.",31,{"inputs":[{"name":"self"},{"name":"st"},{"name":"f"}],"output":{"name":"scan"}}],[11,"flat_map","","Creates an iterator that works like map, but flattens nested structure.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"flatmap"}}],[11,"flatten","","Creates an iterator that flattens nested structure.",31,{"inputs":[{"name":"self"}],"output":{"name":"flatten"}}],[11,"fuse","","Creates an iterator which ends after the first [`None`].",31,{"inputs":[{"name":"self"}],"output":{"name":"fuse"}}],[11,"inspect","","Do something with each element of an iterator, passing the value on.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"inspect"}}],[11,"by_ref","","Borrows an iterator, rather than consuming it.",31,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"collect","","Transforms an iterator into a collection.",31,{"inputs":[{"name":"self"}],"output":{"name":"b"}}],[11,"partition","","Consumes an iterator, creating two collections from it.",31,null],[11,"try_fold","","An iterator method that applies a function as long as it returns successfully, producing a single, final value.",31,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"try_for_each","","An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","An iterator method that applies a function, producing a single, final value.",31,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"b"}}],[11,"all","","Tests if every element of the iterator matches a predicate.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"any","","Tests if any element of the iterator matches a predicate.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"find","","Searches for an element of an iterator that satisfies a predicate.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"find_map","","Applies function to the elements of iterator and returns the first non-none result.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"position","","Searches for an element in an iterator, returning its index.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"rposition","","Searches for an element in an iterator from the right, returning its index.",31,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"max","","Returns the maximum element of an iterator.",31,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"min","","Returns the minimum element of an iterator.",31,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"max_by_key","","Returns the element that gives the maximum value from the specified function.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"max_by","","Returns the element that gives the maximum value with respect to the specified comparison function.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"min_by_key","","Returns the element that gives the minimum value from the specified function.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"min_by","","Returns the element that gives the minimum value with respect to the specified comparison function.",31,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"rev","","Reverses an iterator's direction.",31,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"unzip","","Converts an iterator of pairs into a pair of containers.",31,null],[11,"cloned","","Creates an iterator which [`clone`]s all of its elements.",31,{"inputs":[{"name":"self"}],"output":{"name":"cloned"}}],[11,"cycle","","Repeats an iterator endlessly.",31,{"inputs":[{"name":"self"}],"output":{"name":"cycle"}}],[11,"sum","","Sums the elements of an iterator.",31,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[11,"product","","Iterates over the entire iterator, multiplying all the elements",31,{"inputs":[{"name":"self"}],"output":{"name":"p"}}],[11,"cmp","","Lexicographically compares the elements of this `Iterator` with those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","Lexicographically compares the elements of this `Iterator` with those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"eq","","Determines if the elements of this `Iterator` are equal to those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"ne","","Determines if the elements of this `Iterator` are unequal to those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"lt","","Determines if the elements of this `Iterator` are lexicographically less than those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"le","","Determines if the elements of this `Iterator` are lexicographically less or equal to those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"gt","","Determines if the elements of this `Iterator` are lexicographically greater than those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"ge","","Determines if the elements of this `Iterator` are lexicographically greater than or equal to those of another.",31,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[8,"Sized","","Types with a constant size known at compile time.",null,null],[4,"Option","","The `Option` type. See the module level documentation for more.",null,null],[13,"None","","No value",77,null],[13,"Some","","Some value `T`",77,null],[8,"From","","Simple and safe type conversions in to `Self`. It is the reciprocal of `Into`.",null,null],[10,"from","","Performs the conversion.",15,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[8,"IntoIterator","","Conversion into an `Iterator`.",null,null],[16,"Item","","The type of the elements being iterated over.",32,null],[16,"IntoIter","","Which kind of iterator are we turning this into?",32,null],[10,"into_iter","","Creates an iterator from a value.",32,null],[8,"Fn","","The version of the call operator that takes an immutable receiver.",null,null],[10,"call","","Performs the call operation.",61,null],[8,"PartialOrd","","Trait for values that can be compared for a sort-order.",null,null],[10,"partial_cmp","","This method returns an ordering between `self` and `other` values if one exists.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","This method tests less than (for `self` and `other`) and is used by the `<` operator.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"le","","This method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"gt","","This method tests greater than (for `self` and `other`) and is used by the `>` operator.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"ge","","This method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator.",11,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[8,"Eq","","Trait for equality comparisons which are equivalence relations.",null,null],[8,"Into","","A conversion that consumes `self`, which may or may not be expensive. The reciprocal of [`From`][From].",null,null],[10,"into","","Performs the conversion.",14,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"ExactSizeIterator","","An iterator that knows its exact length.",null,null],[11,"len","","Returns the exact number of times the iterator will iterate.",35,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns whether the iterator is empty.",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"FnMut","","The version of the call operator that takes a mutable receiver.",null,null],[10,"call_mut","","Performs the call operation.",64,null],[8,"Sync","","Types for which it is safe to share references between threads.",null,null],[8,"Ord","","Trait for types that form a total order.",null,null],[10,"cmp","","This method returns an `Ordering` between `self` and `other`.",10,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"max","","Compares and returns the maximum of two values.",10,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"min","","Compares and returns the minimum of two values.",10,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"Clone","","A common trait for the ability to explicitly duplicate an object.",null,null],[10,"clone","","Returns a copy of the value.",86,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone_from","","Performs copy-assignment from `source`.",86,null],[8,"AsMut","","A cheap, mutable reference-to-mutable reference conversion.",null,null],[10,"as_mut","","Performs the conversion.",13,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"DoubleEndedIterator","","An iterator able to yield elements from both ends.",null,null],[10,"next_back","","Removes and returns an element from the end of the iterator.",36,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","This is the reverse version of [`try_fold()`]: it takes elements starting from the back of the iterator.",36,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","An iterator method that reduces the iterator's elements to a single, final value, starting from the back.",36,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"b"}}],[11,"rfind","","Searches for an element of an iterator from the back that satisfies a predicate.",36,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[4,"Result","","`Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).",null,null],[13,"Ok","","Contains the success value",78,null],[13,"Err","","Contains the error value",78,null],[8,"Send","","Types that can be transferred across thread boundaries.",null,null],[8,"Copy","","Types whose values can be duplicated simply by copying bits.",null,null],[8,"Default","","A trait for giving a type a useful default value.",null,null],[10,"default","","Returns the \"default value\" for a type.",87,{"inputs":[],"output":{"name":"self"}}],[8,"AsRef","","A cheap reference-to-reference conversion. Used to convert a value to a reference value within generic code.",null,null],[10,"as_ref","","Performs the conversion.",12,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"fmt","nom","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"hash","","",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"description","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"into_error_kind","","Convert Err into an ErrorKind.",1,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"convert","","",1,{"inputs":[{"name":"errorkind"}],"output":{"name":"self"}}],[0,"simple_errors","","Error management",null,null],[4,"Context","nom::simple_errors","",null,null],[13,"Code","","",88,null],[11,"fmt","","",88,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",88,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"eq","","",88,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"bool"}}],[11,"ne","","",88,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"bool"}}],[11,"convert","","",88,{"inputs":[{"name":"context"}],"output":{"name":"self"}}],[11,"into_error_kind","","Convert Err into ErrorKind.",88,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"fmt","nom","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"needed"}}],[11,"is_known","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"map","","Maps a `Needed` to `Needed` by appling a function to a contained `Size` value.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"needed"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"err"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"err"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"err"}],"output":{"name":"bool"}}],[11,"convert","","",3,{"inputs":[{"name":"err"}],"output":{"name":"self"}}],[11,"into_error_kind","","",3,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"is_incomplete","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"compareresult"}],"output":{"name":"bool"}}],[0,"methods","","Method macro combinators",null,null],[0,"bits","","Bit level parsers and combinators",null,null],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"endianness"}],"output":{"name":"bool"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"endianness"}}],[0,"whitespace","","Support for whitespace delimited formats",null,null],[5,"sp","nom::whitespace","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[0,"types","nom","Custom input types",null,null],[3,"CompleteStr","nom::types","Holds a complete String, for which the `at_eof` method always returns true",null,null],[12,"0","","",89,null],[3,"CompleteByteSlice","","Holds a complete byte array, for which the `at_eof` method always returns true",null,null],[12,"0","","",90,null],[3,"Input","","",null,null],[12,"inner","","",91,null],[12,"at_eof","","",91,null],[11,"clone","","",89,{"inputs":[{"name":"self"}],"output":{"name":"completestr"}}],[11,"fmt","","",89,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",89,{"inputs":[{"name":"self"},{"name":"completestr"}],"output":{"name":"bool"}}],[11,"ne","","",89,{"inputs":[{"name":"self"},{"name":"completestr"}],"output":{"name":"bool"}}],[11,"hash","","",89,null],[11,"from","","",89,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",89,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"fmt","","",89,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"deref","","",89,null],[11,"at_eof","","",89,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"slice","","",89,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"range"}],"output":{"name":"self"}}],[11,"slice","","",89,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangeto"}],"output":{"name":"self"}}],[11,"slice","","",89,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangefrom"}],"output":{"name":"self"}}],[11,"slice","","",89,{"inputs":[{"name":"self"},{"name":"rangefull"}],"output":{"name":"self"}}],[11,"iter_indices","","",89,null],[11,"iter_elements","","",89,null],[11,"position","","",89,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"slice_index","","",89,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["usize"],"name":"option"}}],[11,"take","","",89,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"take_split","","",89,null],[11,"input_len","","",89,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compare","","",89,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"compareresult"}}],[11,"compare_no_case","","",89,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"compareresult"}}],[11,"find_substring","","",89,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["usize"],"name":"option"}}],[11,"find_token","","",89,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"name":"bool"}}],[11,"find_token","","",89,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"find_token","","",89,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"parse_to","","",89,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"offset","","",89,{"inputs":[{"name":"self"},{"name":"completestr"}],"output":{"name":"usize"}}],[11,"as_bytes","","",89,null],[11,"new_builder","","",89,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"extend_into","","",89,{"inputs":[{"name":"self"},{"name":"string"}],"output":null}],[11,"clone","","",90,{"inputs":[{"name":"self"}],"output":{"name":"completebyteslice"}}],[11,"fmt","","",90,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",90,{"inputs":[{"name":"self"},{"name":"completebyteslice"}],"output":{"name":"bool"}}],[11,"ne","","",90,{"inputs":[{"name":"self"},{"name":"completebyteslice"}],"output":{"name":"bool"}}],[11,"hash","","",90,null],[11,"from","","",90,null],[11,"from","","",90,null],[11,"deref","","",90,null],[11,"at_eof","","",90,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"slice","","",90,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"range"}],"output":{"name":"self"}}],[11,"slice","","",90,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangeto"}],"output":{"name":"self"}}],[11,"slice","","",90,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangefrom"}],"output":{"name":"self"}}],[11,"slice","","",90,{"inputs":[{"name":"self"},{"name":"rangefull"}],"output":{"name":"self"}}],[11,"iter_indices","","",90,null],[11,"iter_elements","","",90,null],[11,"position","","",90,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"slice_index","","",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["usize"],"name":"option"}}],[11,"take","","",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"take_split","","",90,null],[11,"input_len","","",90,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compare","","",90,null],[11,"compare_no_case","","",90,null],[11,"compare","","",90,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"compareresult"}}],[11,"compare_no_case","","",90,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"compareresult"}}],[11,"find_substring","","",90,null],[11,"find_substring","","",90,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["usize"],"name":"option"}}],[11,"find_token","","",90,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"name":"bool"}}],[11,"find_token","","",90,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"find_token","","",90,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"parse_to","","",90,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"offset","","",90,{"inputs":[{"name":"self"},{"name":"completebyteslice"}],"output":{"name":"usize"}}],[11,"as_bytes","","",90,null],[11,"clone","","",91,{"inputs":[{"name":"self"}],"output":{"name":"input"}}],[11,"fmt","","",91,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",91,{"inputs":[{"name":"self"},{"name":"input"}],"output":{"name":"bool"}}],[11,"ne","","",91,{"inputs":[{"name":"self"},{"name":"input"}],"output":{"name":"bool"}}],[11,"hash","","",91,null],[11,"at_eof","","",91,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"slice","","",91,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"range"}],"output":{"name":"self"}}],[11,"slice","","",91,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangeto"}],"output":{"name":"self"}}],[11,"slice","","",91,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangefrom"}],"output":{"name":"self"}}],[11,"slice","","",91,{"inputs":[{"name":"self"},{"name":"rangefull"}],"output":{"name":"self"}}],[11,"iter_indices","","",91,null],[11,"iter_elements","","",91,null],[11,"position","","",91,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"slice_index","","",91,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["usize"],"name":"option"}}],[11,"take","","",91,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"take_split","","",91,null],[11,"input_len","","",91,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compare","","",91,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"compareresult"}}],[11,"compare_no_case","","",91,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"compareresult"}}],[11,"find_substring","","",91,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["usize"],"name":"option"}}],[11,"find_token","","",91,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"name":"bool"}}],[11,"find_token","","",91,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"find_token","","",91,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"parse_to","","",91,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"offset","","",91,{"inputs":[{"name":"self"},{"name":"input"}],"output":{"name":"usize"}}],[11,"as_bytes","","",91,null],[6,"IResult","nom","Holds the result of parsing functions",null,null],[8,"InputLength","","abstract method to calculate the input length",null,null],[10,"input_len","","calculates the input length, as indicated by its name, and the name of the trait itself",92,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"Offset","","useful functions to calculate the offset between slices and show a hexdump of a slice",null,null],[10,"offset","","offset between the first byte of self and the first byte of the argument",93,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"usize"}}],[8,"AsBytes","","casts the input type to a byte slice",null,null],[10,"as_bytes","","",94,null],[8,"AsChar","","transforms common types to a char for basic token parsing",null,null],[10,"as_char","","makes a char from self",95,{"inputs":[{"name":"self"}],"output":{"name":"char"}}],[10,"is_alpha","","tests that self is an alphabetic character",95,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_alphanum","","tests that self is an alphabetic character or a decimal digit",95,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_dec_digit","","tests that self is a decimal digit",95,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_hex_digit","","tests that self is an hex digit",95,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_oct_digit","","tests that self is an octal digit",95,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"len","","gets the len in bytes for self",95,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"InputIter","","abstracts common iteration operations on the input type",null,null],[16,"Item","","",96,null],[16,"RawItem","","",96,null],[16,"Iter","","",96,null],[16,"IterElem","","",96,null],[10,"iter_indices","","returns an iterator over the elements and their byte offsets",96,null],[10,"iter_elements","","returns an iterator over the elements",96,null],[10,"position","","finds the byte position of the element",96,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[10,"slice_index","","get the byte offset from the element's position in the stream",96,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["usize"],"name":"option"}}],[8,"InputTake","","abstracts slicing operations",null,null],[10,"take","","returns a slice of `count` bytes. panics if count > length",97,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[10,"take_split","","split the stream at the `count` byte offset. panics if count > length",97,null],[8,"UnspecializedInput","","Dummy trait used for default implementations (currently only used for `InputTakeAtPosition`).",null,null],[8,"InputTakeAtPosition","","methods to take as much input as possible until the provided function returns true for the current element",null,null],[16,"Item","","",98,null],[10,"split_at_position","","",98,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["u32"],"name":"iresult"}}],[10,"split_at_position1","","",98,{"inputs":[{"name":"self"},{"name":"p"},{"generics":["u32"],"name":"errorkind"}],"output":{"generics":["u32"],"name":"iresult"}}],[8,"Compare","","abstracts comparison operations",null,null],[10,"compare","","compares self to another value for equality",99,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"compareresult"}}],[10,"compare_no_case","","compares self to another value for equality independently of the case.",99,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"compareresult"}}],[8,"FindToken","","look for self in the given input stream",null,null],[10,"find_token","","",100,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[8,"FindSubstring","","look for a substring in self",null,null],[10,"find_substring","","",101,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["usize"],"name":"option"}}],[8,"ParseTo","","used to integrate str's parse() method",null,null],[10,"parse_to","","",102,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[8,"Slice","","slicing operations using ranges",null,null],[10,"slice","","",103,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"self"}}],[8,"AtEof","","indicates whether more data can come later in input",null,null],[10,"at_eof","","",104,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"ExtendInto","","abtracts something which can extend an `Extend`",null,null],[16,"Item","","",105,null],[16,"Extender","","",105,null],[10,"new_builder","","create a new `Extend` of the correct type",105,null],[10,"extend_into","","accumulate the input into an accumulator",105,null],[8,"Convert","","",null,null],[10,"convert","","",106,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[14,"dbg","","Prints a message if the parser fails",null,null],[14,"dbg_dmp","","Prints a message and the input if the parser fails",null,null],[14,"fix_error","","translate parser result from IResult<I,O,u32> to IResult<I,O,E> with a custom type",null,null],[14,"flat_map","","`flat_map!(R -> IResult<R,S>, S -> IResult<S,T>) => R -> IResult<R, T>`",null,null],[14,"error_position","","creates a parse error from a `nom::ErrorKind` and the position in the input if \"verbose-errors\" is not activated, it default to only the error code",null,null],[14,"error_node_position","","creates a parse error from a `nom::ErrorKind`, the position in the input and the next error in the parsing tree. if \"verbose-errors\" is not activated, it default to only the error code",null,null],[14,"closure","","Wraps a parser in a closure",null,null],[14,"named","","Makes a function from a parser combination",null,null],[14,"named_args","","Makes a function from a parser combination with arguments.",null,null],[14,"named_attr","","Makes a function from a parser combination, with attributes",null,null],[14,"call","","Used to wrap common expressions and function as macros",null,null],[14,"apply","","emulate function currying: `apply!(my_function, arg1, arg2, ...)` becomes `my_function(input, arg1, arg2, ...)`",null,null],[14,"return_error","","Prevents backtracking if the child parser fails",null,null],[14,"add_return_error","","Add an error if the child parser fails",null,null],[14,"complete","","replaces a `Incomplete` returned by the child parser with an `Error`",null,null],[14,"try_parse","","A bit like `std::try!`, this macro will return the remaining input and parsed value if the child parser returned `Ok`, and will do an early return for the `Err` side.",null,null],[14,"map","","`map!(I -> IResult<I,O>, O -> P) => I -> IResult<I, P>` maps a function on the result of a parser",null,null],[14,"map_res","","`map_res!(I -> IResult<I,O>, O -> Result<P>) => I -> IResult<I, P>` maps a function returning a Result on the output of a parser",null,null],[14,"map_opt","","`map_opt!(I -> IResult<I,O>, O -> Option<P>) => I -> IResult<I, P>` maps a function returning an Option on the output of a parser",null,null],[14,"parse_to","","`parse_to!(O) => I -> IResult<I, O>` uses the `parse` method from `std::str::FromStr` to convert the current input to the specified type",null,null],[14,"verify","","`verify!(I -> IResult<I,O>, O -> bool) => I -> IResult<I, O>` returns the result of the child parser if it satisfies a verification function",null,null],[14,"value","","`value!(T, R -> IResult<R, S> ) => R -> IResult<R, T>`",null,null],[14,"expr_res","","`expr_res!(Result<E,O>) => I -> IResult<I, O>` evaluate an expression that returns a Result<T,E> and returns a Ok((I,T)) if Ok",null,null],[14,"expr_opt","","`expr_opt!(Option<O>) => I -> IResult<I, O>` evaluate an expression that returns a Option and returns a Ok((I,T)) if Some",null,null],[14,"opt","","`opt!(I -> IResult<I,O>) => I -> IResult<I, Option<O>>` make the underlying parser optional",null,null],[14,"opt_res","","`opt_res!(I -> IResult<I,O>) => I -> IResult<I, Result<nom::Err,O>>` make the underlying parser optional",null,null],[14,"cond_with_error","","`cond_with_error!(bool, I -> IResult<I,O>) => I -> IResult<I, Option<O>>` Conditional combinator",null,null],[14,"cond","","`cond!(bool, I -> IResult<I,O>) => I -> IResult<I, Option<O>>` Conditional combinator",null,null],[14,"cond_reduce","","`cond_reduce!(bool, I -> IResult<I,O>) => I -> IResult<I, O>` Conditional combinator with error",null,null],[14,"peek","","`peek!(I -> IResult<I,O>) => I -> IResult<I, O>` returns a result without consuming the input",null,null],[14,"not","","`not!(I -> IResult<I,O>) => I -> IResult<I, O>` returns a result only if the embedded parser returns Error or Err(Err::Incomplete) does not consume the input",null,null],[14,"tap","","`tap!(name: I -> IResult<I,O> => { block }) => I -> IResult<I, O>` allows access to the parser's result without affecting it",null,null],[14,"eof","","`eof!()` returns its input if it is at the end of input data",null,null],[14,"exact","","`exact!()` will fail if the child parser does not consume the whole data",null,null],[14,"recognize","","`recognize!(I -> IResult<I, O> ) => I -> IResult<I, I>` if the child parser was successful, return the consumed input as produced value",null,null],[14,"alt","","Try a list of parsers and return the result of the first successful one",null,null],[14,"alt_complete","","Is equivalent to the `alt!` combinator, except that it will not return `Incomplete` when one of the constituting parsers returns `Incomplete`. Instead, it will try the next alternative in the chain.",null,null],[14,"switch","","`switch!(I -> IResult<I,P>, P => I -> IResult<I,O> | ... | P => I -> IResult<I,O> ) => I -> IResult<I, O>` choose the next parser depending on the result of the first one, if successful, and returns the result of the second parser",null,null],[14,"permutation","","`permutation!(I -> IResult<I,A>, I -> IResult<I,B>, ... I -> IResult<I,X> ) => I -> IResult<I, (A,B,...X)>` applies its sub parsers in a sequence, but independent from their order this parser will only succeed if all of its sub parsers succeed",null,null],[14,"tuple","","`tuple!(I->IResult<I,A>, I->IResult<I,B>, ... I->IResult<I,X>) => I -> IResult<I, (A, B, ..., X)>` chains parsers and assemble the sub results in a tuple.",null,null],[14,"pair","","`pair!(I -> IResult<I,O>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>` pair(X,Y), returns (x,y)",null,null],[14,"separated_pair","","`separated_pair!(I -> IResult<I,O>, I -> IResult<I, T>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>` separated_pair(X,sep,Y) returns (x,y)",null,null],[14,"preceded","","`preceded!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, O>` preceded(opening, X) returns X",null,null],[14,"terminated","","`terminated!(I -> IResult<I,O>, I -> IResult<I,T>) => I -> IResult<I, O>` terminated(X, closing) returns X",null,null],[14,"delimited","","`delimited!(I -> IResult<I,T>, I -> IResult<I,O>, I -> IResult<I,U>) => I -> IResult<I, O>` delimited(opening, X, closing) returns X",null,null],[14,"do_parse","","`do_parse!(I->IResult<I,A> >> I->IResult<I,B> >> ... I->IResult<I,X> , ( O ) ) => I -> IResult<I, O>` do_parse applies sub parsers in a sequence. it can store intermediary results and make them available for later parsers",null,null],[14,"separated_list","","`separated_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` separated_list(sep, X) returns Vec will return Incomplete if there may be more elements",null,null],[14,"separated_nonempty_list","","`separated_nonempty_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` separated_nonempty_list(sep, X) returns Vec will return Incomplete if there may be more elements",null,null],[14,"separated_list_complete","","`separated_list_complete!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` This is equivalent to the `separated_list!` combinator, except that it will return `Error` when either the separator or element subparser returns `Incomplete`.",null,null],[14,"separated_nonempty_list_complete","","`separated_nonempty_list_complete!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` This is equivalent to the `separated_nonempty_list!` combinator, except that it will return `Error` when either the separator or element subparser returns `Incomplete`.",null,null],[14,"many0","","`many0!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` Applies the parser 0 or more times and returns the list of results in a Vec.",null,null],[14,"many1","","`many1!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` Applies the parser 1 or more times and returns the list of results in a Vec",null,null],[14,"many_till","","`many_till!(I -> IResult<I,O>, I -> IResult<I,P>) => I -> IResult<I, (Vec<O>, P)>` Applies the first parser until the second applies. Returns a tuple containing the list of results from the first in a Vec and the result of the second.",null,null],[14,"many_m_n","","`many_m_n!(usize, usize, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` Applies the parser between m and n times (n included) and returns the list of results in a Vec",null,null],[14,"count","","`count!(I -> IResult<I,O>, nb) => I -> IResult<I, Vec<O>>` Applies the child parser a specified number of times",null,null],[14,"count_fixed","","`count_fixed!(O, I -> IResult<I,O>, nb) => I -> IResult<I, [O; nb]>` Applies the child parser a fixed number of times and returns a fixed size array The type must be specified and it must be `Copy`",null,null],[14,"length_count","","`length_count!(I -> IResult<I, nb>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` gets a number from the first parser, then applies the second parser that many times",null,null],[14,"length_data","","`length_data!(I -> IResult<I, nb>) => O`",null,null],[14,"length_value","","`length_value!(I -> IResult<I, nb>, I -> IResult<I,O>) => I -> IResult<I, O>`",null,null],[14,"fold_many0","","`fold_many0!(I -> IResult<I,O>, R, Fn(R, O) -> R) => I -> IResult<I, R>` Applies the parser 0 or more times and folds the list of return values",null,null],[14,"fold_many1","","`fold_many1!(I -> IResult<I,O>, R, Fn(R, O) -> R) => I -> IResult<I, R>` Applies the parser 1 or more times and folds the list of return values",null,null],[14,"fold_many_m_n","","`fold_many_m_n!(usize, usize, I -> IResult<I,O>, R, Fn(R, O) -> R) => I -> IResult<I, R>` Applies the parser between m and n times (n included) and folds the list of return value",null,null],[14,"method","","Makes a method from a parser combination",null,null],[14,"call_m","","Used to called methods then move self back into self",null,null],[14,"apply_m","","emulate function currying for method calls on structs `apply_m!(self.my_function, arg1, arg2, ...)` becomes `self.my_function(input, arg1, arg2, ...)`",null,null],[14,"tag","","`tag!(&[T]: nom::AsBytes) => &[T] -> IResult<&[T], &[T]>` declares a byte array as a suite to recognize",null,null],[14,"tag_no_case","","`tag_no_case!(&[T]) => &[T] -> IResult<&[T], &[T]>` declares a case insensitive ascii string as a suite to recognize",null,null],[14,"is_not","","`is_not!(&[T:AsBytes]) => &[T] -> IResult<&[T], &[T]>` returns the longest list of bytes that do not appear in the provided array",null,null],[14,"is_a","","`is_a!(&[T]) => &[T] -> IResult<&[T], &[T]>` returns the longest list of bytes that appear in the provided array",null,null],[14,"escaped","","`escaped!(T -> IResult<T, T>, U, T -> IResult<T, T>) => T -> IResult<T, T> where T: InputIter, U: AsChar` matches a byte string with escaped characters.",null,null],[14,"escaped_transform","","`escaped_transform!(&[T] -> IResult<&[T], &[T]>, T, &[T] -> IResult<&[T], &[T]>) => &[T] -> IResult<&[T], Vec<T>>` matches a byte string with escaped characters.",null,null],[14,"take_while","","`take_while!(T -> bool) => &[T] -> IResult<&[T], &[T]>` returns the longest list of bytes until the provided function fails.",null,null],[14,"take_while1","","`take_while1!(T -> bool) => &[T] -> IResult<&[T], &[T]>` returns the longest (non empty) list of bytes until the provided function fails.",null,null],[14,"take_while_m_n","","`take_while_m_n!(m: usize, n: usize, T -> bool) => &[T] -> IResult<&[T], &[T]>` returns a list of bytes or characters for which the provided function returns true. the returned list's size will be at least m, and at most n",null,null],[14,"take_till","","`take_till!(T -> bool) => &[T] -> IResult<&[T], &[T]>` returns the longest list of bytes until the provided function succeeds",null,null],[14,"take_till1","","`take_till1!(T -> bool) => &[T] -> IResult<&[T], &[T]>` returns the longest non empty list of bytes until the provided function succeeds",null,null],[14,"take","","`take!(nb) => &[T] -> IResult<&[T], &[T]>` generates a parser consuming the specified number of bytes",null,null],[14,"take_str","","`take_str!(nb) => &[T] -> IResult<&[T], &str>` same as take! but returning a &str",null,null],[14,"take_until_and_consume","","`take_until_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>` generates a parser consuming bytes until the specified byte sequence is found, and consumes it",null,null],[14,"take_until_and_consume1","","`take_until_and_consume1!(tag) => &[T] -> IResult<&[T], &[T]>` generates a parser consuming bytes (at least 1) until the specified byte sequence is found, and consumes it",null,null],[14,"take_until","","`take_until!(tag) => &[T] -> IResult<&[T], &[T]>` consumes data until it finds the specified tag.",null,null],[14,"take_until1","","`take_until1!(tag) => &[T] -> IResult<&[T], &[T]>` consumes data (at least one byte) until it finds the specified tag",null,null],[14,"take_until_either_and_consume","","`take_until_either_and_consume!(chars) => &[T] -> IResult<&[T], &[T]>` consumes data until it finds any of the specified characters, and consume it",null,null],[14,"take_until_either_and_consume1","","`take_until_either_and_consume1!(chars) => &[T] -> IResult<&[T], &[T]>` consumes data (at least one byte) until it finds any of the specified characters, and consume it",null,null],[14,"take_until_either","","`take_until_either!(tag) => &[T] -> IResult<&[T], &[T]>` consumes data until it finds any of the specified characters",null,null],[14,"take_until_either1","","`take_until_either1!(tag) => &[T] -> IResult<&[T], &[T]>` consumes data (at least one byte) until it finds any of the specified characters",null,null],[14,"length_bytes","","`length_bytes!(&[T] -> IResult<&[T], nb>) => &[T] -> IResult<&[T], &[T]>` Gets a number from the first parser, then extracts that many bytes from the remaining stream",null,null],[14,"bits","","Transforms its byte slice input into a bit stream for the underlying parser. This allows the given bit stream parser to work on a byte slice input.",null,null],[14,"bytes","","Counterpart to bits, bytes! transforms its bit stream input into a byte slice for the underlying parser, allowing byte-slice parsers to work on bit streams.",null,null],[14,"take_bits","","Consumes the specified number of bits and returns them as the specified type.",null,null],[14,"tag_bits","","Matches the given bit pattern.",null,null],[14,"one_of","","matches one of the provided characters",null,null],[14,"none_of","","matches anything but the provided characters",null,null],[14,"char","","matches one character: `char!(char) => &[u8] -> IResult<&[u8], char>",null,null],[14,"u16","","if the parameter is nom::Endianness::Big, parse a big endian u16 integer, otherwise a little endian u16 integer",null,null],[14,"u32","","if the parameter is nom::Endianness::Big, parse a big endian u32 integer, otherwise a little endian u32 integer",null,null],[14,"u64","","if the parameter is nom::Endianness::Big, parse a big endian u64 integer, otherwise a little endian u64 integer",null,null],[14,"i16","","if the parameter is nom::Endianness::Big, parse a big endian i16 integer, otherwise a little endian i16 integer",null,null],[14,"i32","","if the parameter is nom::Endianness::Big, parse a big endian i32 integer, otherwise a little endian i32 integer",null,null],[14,"i64","","if the parameter is nom::Endianness::Big, parse a big endian i64 integer, otherwise a little endian i64 integer",null,null],[14,"wrap_sep","","",null,null],[14,"eat_separator","","helper macros to build a separator parser",null,null],[14,"sep","","sep is the parser rewriting macro for whitespace separated formats",null,null],[14,"ws","","`ws!(I -> IResult<I,O>) => I -> IResult<I, O>`",null,null],[14,"tag_s","","`tag_s!(&str) => &str -> IResult<&str, &str>` declares a string as a suite to recognize",null,null],[14,"tag_no_case_s","","`tag_no_case_s!(&str) => &str -> IResult<&str, &str>` declares a case-insensitive string as a suite to recognize",null,null],[14,"take_s","","`take_s!(nb) => &str -> IResult<&str, &str>` generates a parser consuming the specified number of characters",null,null],[14,"is_not_s","","`is_not_s!(&str) => &str -> IResult<&str, &str>` returns the longest list of characters that do not appear in the provided array",null,null],[14,"is_a_s","","`is_a_s!(&str) => &str -> IResult<&str, &str>` returns the longest list of characters that appear in the provided array",null,null],[14,"take_while_s","","`take_while_s!(char -> bool) => &str -> IResult<&str, &str>` returns the longest list of characters until the provided function fails.",null,null],[14,"take_while1_s","","`take_while1_s!(char -> bool) => &str -> IResult<&str, &str>` returns the longest (non empty) list of characters until the provided function fails.",null,null],[14,"take_till_s","","`take_till_s!(char -> bool) => &str -> IResult<&str, &str>` returns the longest list of characters until the provided function succeeds",null,null],[14,"take_till1_s","","`take_till1_s!(char -> bool) => &str -> IResult<&str, &str>` returns the longest non empty list of characters until the provided function succeeds",null,null],[14,"take_until_and_consume_s","","`take_until_and_consume_s!(&str) => &str -> IResult<&str, &str>` generates a parser consuming all chars until the specified string is found and consumes it",null,null],[14,"take_until_s","","`take_until_s!(&str) => &str -> IResult<&str, &str>` generates a parser consuming all chars until the specified string is found and leaves it in the remaining input",null,null],[11,"new","nom::lib::std::boxed","Allocates memory on the heap and then places `x` into it.",107,{"inputs":[{"name":"t"}],"output":{"name":"box"}}],[11,"from_raw","","Constructs a box from a raw pointer.",107,null],[11,"into_raw","","Consumes the `Box`, returning the wrapped raw pointer.",107,null],[11,"into_raw_non_null","","Consumes the `Box`, returning the wrapped pointer as `NonNull<T>`.",107,{"inputs":[{"name":"box"}],"output":{"name":"nonnull"}}],[11,"leak","","Consumes and leaks the `Box`, returning a mutable reference, `&'a mut T`. Here, the lifetime `'a` may be chosen to be `'static`.",107,{"inputs":[{"name":"box"}],"output":{"name":"t"}}],[11,"downcast","","Attempt to downcast the box to a concrete type.",107,{"inputs":[{"name":"self"}],"output":{"generics":["box","box"],"name":"result"}}],[11,"downcast","","Attempt to downcast the box to a concrete type.",107,{"inputs":[{"name":"self"}],"output":{"generics":["box","box"],"name":"result"}}],[11,"start","nom::lib::std::ops","",108,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",108,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",57,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",57,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",40,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",40,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",50,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",50,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",109,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",109,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",109,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",109,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",50,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",50,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",57,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",57,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",67,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",67,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",67,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",67,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"start","","",40,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"end","","",40,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"next","nom::lib::std::iter","",110,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",110,null],[11,"try_fold","","",110,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",110,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","","",111,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",111,null],[11,"try_fold","","",111,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",111,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"find","","",111,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"rposition","","",111,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"next","nom::lib::std::str","",112,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","nom::lib::std::iter","",113,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",113,null],[11,"try_fold","","",113,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",113,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::str","",114,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"size_hint","","",114,null],[11,"next","nom::lib::std::slice","",115,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",115,null],[11,"count","","",115,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",115,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",115,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::str","",116,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","","",117,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::iter","",118,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",118,null],[11,"next","nom::lib::std::result","",119,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",119,null],[11,"next","nom::lib::std::str","",120,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"count","","",120,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","",120,null],[11,"last","","",120,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"next","nom::lib::std::iter","",121,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",121,null],[11,"next","","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",122,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",122,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","",122,null],[11,"try_fold","","",122,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",122,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::ops","",57,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",57,null],[11,"nth","","",57,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::iter","",123,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",123,null],[11,"try_fold","","",123,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"next","nom::lib::std::slice","",124,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",124,null],[11,"next","nom::lib::std::str","",125,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","","",126,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"option"}}],[11,"size_hint","","",126,null],[11,"count","","",126,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",126,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",126,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"all","","",126,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"any","","",126,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"find","","",126,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"position","","",126,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"rposition","","",126,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"next","nom::lib::std::iter","",127,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",127,null],[11,"next","nom::lib::std::option","",128,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",128,null],[11,"next","nom::lib::std::result","",129,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",129,null],[11,"next","nom::lib::std::iter","",130,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",130,null],[11,"nth","","",130,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",131,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"count","","",131,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",131,null],[11,"try_fold","","",131,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",131,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::str","",132,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","nom::lib::std::iter","",133,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",133,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",133,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",133,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",133,null],[11,"try_fold","","",133,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",133,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","","",134,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",134,null],[11,"try_fold","","",134,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",134,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::result","",135,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",135,null],[11,"next","nom::lib::std::str","",136,{"inputs":[{"name":"self"}],"output":{"generics":["u16"],"name":"option"}}],[11,"size_hint","","",136,null],[11,"next","nom::lib::std::slice","",137,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",137,null],[11,"next","nom::lib::std::iter","Overflow Behavior",138,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",138,null],[11,"nth","","",138,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"count","","",138,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"try_fold","","",138,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",138,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::slice","",139,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",139,null],[11,"next","nom::lib::std::iter","",140,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",140,null],[11,"next","nom::lib::std::str::lossy","",141,{"inputs":[{"name":"self"}],"output":{"generics":["utf8lossychunk"],"name":"option"}}],[11,"next","nom::lib::std::slice","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",142,null],[11,"count","","",142,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",142,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_fold","","",142,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"position","","",142,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"rposition","","",142,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"next","nom::lib::std::str","",143,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","nom::lib::std::slice","",144,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",144,null],[11,"next","nom::lib::std::iter","",145,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",145,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"try_fold","","",145,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",145,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"nth","","",145,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"find","","",145,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"last","","",145,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",145,null],[11,"next","","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",122,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",122,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","",122,null],[11,"try_fold","","",122,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",122,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::slice","",146,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",146,null],[11,"next","nom::lib::std::iter","",147,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",147,null],[11,"count","","",147,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"try_fold","","",147,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",147,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::ops","",67,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",67,null],[11,"nth","","",67,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",67,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"min","","",67,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"max","","",67,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::str","",148,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","nom::lib::std::iter","",149,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",149,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"size_hint","","",149,null],[11,"try_fold","","",149,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"next","nom::lib::std::slice","",150,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",150,null],[11,"next","nom::lib::std::option","",151,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",151,null],[11,"next","nom::lib::std::slice","",152,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",152,null],[11,"count","","",152,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",152,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",152,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::iter","",153,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",153,null],[11,"try_fold","","",153,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",153,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","","",154,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",154,null],[11,"try_fold","","",154,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",154,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::slice","",155,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",155,null],[11,"next","nom::lib::std::ops","",109,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",109,null],[11,"nth","","",109,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",109,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"min","","",109,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"max","","",109,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_fold","","",109,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"next","nom::lib::std::str","",156,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","","",157,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::option","",158,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",158,null],[11,"next","nom::lib::std::slice","",159,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",159,null],[11,"count","","",159,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",159,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",159,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::str","",160,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","nom::lib::std::iter","",161,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",161,null],[11,"try_fold","","",161,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",161,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::str","",162,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",162,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","",162,null],[11,"last","","",162,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::iter","",163,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",163,null],[11,"nth","","",163,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::slice","",164,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",164,null],[11,"count","","",164,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",164,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",164,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::iter","",165,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",165,null],[11,"try_fold","","",165,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"g"}],"output":{"name":"r"}}],[11,"fold","","",165,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"g"}],"output":{"name":"acc"}}],[11,"next","nom::lib::std::str","",166,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","nom::lib::std::iter","",167,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",167,null],[11,"next","nom::lib::std::slice","",168,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",168,null],[11,"count","","",168,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",168,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",168,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_fold","","",168,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",168,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"position","","",168,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"rposition","","",168,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"next","nom::lib::std::str","",169,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"size_hint","","",169,null],[11,"next","nom::lib::std::slice","",170,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",170,null],[11,"next","","",171,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",171,null],[11,"count","","",171,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",171,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",171,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::iter","",172,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",172,null],[11,"try_fold","","",172,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"deref_mut","nom::lib::std::mem","",173,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",174,null],[11,"from","nom::lib::std::prelude::v1::v1","",77,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[11,"write_str","nom::lib::std::fmt","",175,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_char","","",175,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_fmt","","",175,{"inputs":[{"name":"self"},{"name":"arguments"}],"output":{"generics":["error"],"name":"result"}}],[11,"deref","nom::lib::std::mem","",173,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref","","",174,null],[11,"as_ref","nom::lib::std::slice","",142,null],[11,"product","nom::lib::std::prelude::v1::v1","Takes each element in the `Iterator`: if it is an `Err`, no further elements are taken, and the `Err` is returned. Should no `Err` occur, the product of all elements is returned.",78,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"clone","nom::lib::std::str","",117,{"inputs":[{"name":"self"}],"output":{"name":"rmatchindices"}}],[11,"clone","","",114,{"inputs":[{"name":"self"}],"output":{"name":"lines"}}],[11,"clone","","",162,{"inputs":[{"name":"self"}],"output":{"name":"charindices"}}],[11,"clone","nom::lib::std::iter","",172,{"inputs":[{"name":"self"}],"output":{"name":"takewhile"}}],[11,"clone","","",167,{"inputs":[{"name":"self"}],"output":{"name":"cycle"}}],[11,"clone","nom::lib::std::str","",176,{"inputs":[{"name":"self"}],"output":{"name":"parseboolerror"}}],[11,"clone","","",157,{"inputs":[{"name":"self"}],"output":{"name":"matchindices"}}],[11,"clone","nom::lib::std::str::pattern","",177,{"inputs":[{"name":"self"}],"output":{"name":"strsearcher"}}],[11,"clone","nom::lib::std::str","",178,{"inputs":[{"name":"self"}],"output":{"name":"utf8error"}}],[11,"clone","","",136,{"inputs":[{"name":"self"}],"output":{"name":"encodeutf16"}}],[11,"clone","","",132,{"inputs":[{"name":"self"}],"output":{"name":"splitn"}}],[11,"clone","nom::lib::std::option","",158,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"clone","nom::lib::std::iter","",147,{"inputs":[{"name":"self"}],"output":{"name":"filter"}}],[11,"clone","nom::lib::std::slice","",171,{"inputs":[{"name":"self"}],"output":{"name":"chunks"}}],[11,"clone","nom::lib::std::iter","",140,{"inputs":[{"name":"self"}],"output":{"name":"repeat"}}],[11,"clone","nom::lib::std::ops","",50,{"inputs":[{"name":"self"}],"output":{"name":"rangetoinclusive"}}],[11,"clone","nom::lib::std::iter","",123,{"inputs":[{"name":"self"}],"output":{"name":"scan"}}],[11,"clone","nom::lib::std::str::pattern","",179,{"inputs":[{"name":"self"}],"output":{"name":"charsearcher"}}],[11,"clone","nom::lib::std::str","",126,{"inputs":[{"name":"self"}],"output":{"name":"bytes"}}],[11,"clone","nom::lib::std::iter","",163,{"inputs":[{"name":"self"}],"output":{"name":"zip"}}],[11,"clone","","",153,{"inputs":[{"name":"self"}],"output":{"name":"flatmap"}}],[11,"clone","nom::lib::std::str","",143,{"inputs":[{"name":"self"}],"output":{"name":"matches"}}],[11,"clone","nom::lib::std::iter","",110,{"inputs":[{"name":"self"}],"output":{"name":"inspect"}}],[11,"clone","","",130,{"inputs":[{"name":"self"}],"output":{"name":"stepby"}}],[11,"clone","nom::lib::std::ops","",71,{"inputs":[{"name":"self"}],"output":{"name":"bound"}}],[11,"clone","","",108,{"inputs":[{"name":"self"}],"output":{"name":"rangefull"}}],[11,"clone","nom::lib::std::iter","",133,{"inputs":[{"name":"self"}],"output":{"name":"peekable"}}],[11,"clone","","",113,{"inputs":[{"name":"self"}],"output":{"name":"cloned"}}],[11,"clone","nom::lib::std::cmp","",8,{"inputs":[{"name":"self"}],"output":{"name":"ordering"}}],[11,"clone","nom::lib::std::iter","",145,{"inputs":[{"name":"self"}],"output":{"name":"chain"}}],[11,"clone","","",111,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"clone","","",161,{"inputs":[{"name":"self"}],"output":{"name":"filtermap"}}],[11,"clone","nom::lib::std::result","",135,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"clone","","",129,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"clone","nom::lib::std::fmt","",180,{"inputs":[{"name":"self"}],"output":{"name":"arguments"}}],[11,"clone","nom::lib::std::str::pattern","",181,{"inputs":[{"name":"self"}],"output":{"name":"charslicesearcher"}}],[11,"clone","nom::lib::std::str","",160,{"inputs":[{"name":"self"}],"output":{"name":"rsplitn"}}],[11,"clone","","",120,{"inputs":[{"name":"self"}],"output":{"name":"chars"}}],[11,"clone","nom::lib::std::mem","",174,{"inputs":[{"name":"self"}],"output":{"name":"manuallydrop"}}],[11,"clone_from","","",174,null],[11,"clone","nom::lib::std::ops","",57,{"inputs":[{"name":"self"}],"output":{"name":"rangefrom"}}],[11,"clone","nom::lib::std::slice","",142,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"clone","nom::lib::std::ops","",67,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"clone","nom::lib::std::iter","",118,{"inputs":[{"name":"self"}],"output":{"name":"empty"}}],[11,"clone","nom::lib::std::str::pattern","",182,{"inputs":[{"name":"self"}],"output":{"name":"charpredicatesearcher"}}],[11,"clone","nom::lib::std::fmt","",183,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"clone","nom::lib::std::option","",184,{"inputs":[{"name":"self"}],"output":{"name":"noneerror"}}],[11,"clone","nom::lib::std::iter","",134,{"inputs":[{"name":"self"}],"output":{"name":"skipwhile"}}],[11,"clone","nom::lib::std::ops","",109,{"inputs":[{"name":"self"}],"output":{"name":"rangeinclusive"}}],[11,"clone","nom::lib::std::iter","",131,{"inputs":[{"name":"self"}],"output":{"name":"skip"}}],[11,"clone","nom::lib::std::cmp","",9,{"inputs":[{"name":"self"}],"output":{"name":"reverse"}}],[11,"clone","nom::lib::std::iter","",121,{"inputs":[{"name":"self"}],"output":{"name":"repeatwith"}}],[11,"clone","","",165,{"inputs":[{"name":"self"}],"output":{"name":"map"}}],[11,"clone","","",138,{"inputs":[{"name":"self"}],"output":{"name":"enumerate"}}],[11,"clone","nom::lib::std::str::pattern","",81,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"clone","nom::lib::std::mem","",185,{"inputs":[{"name":"self"}],"output":{"name":"discriminant"}}],[11,"clone","nom::lib::std::str","",156,{"inputs":[{"name":"self"}],"output":{"name":"splitwhitespace"}}],[11,"clone","nom::lib::std::iter","",127,{"inputs":[{"name":"self"}],"output":{"name":"once"}}],[11,"clone","nom::lib::std::str","",148,{"inputs":[{"name":"self"}],"output":{"name":"splitterminator"}}],[11,"clone","nom::lib::std::prelude::v1::v1","",78,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"clone","nom::lib::std::ops","",73,{"inputs":[{"name":"self"}],"output":{"name":"generatorstate"}}],[11,"clone","nom::lib::std::iter","",154,{"inputs":[{"name":"self"}],"output":{"name":"flatten"}}],[11,"clone","nom::lib::std::slice","",115,{"inputs":[{"name":"self"}],"output":{"name":"windows"}}],[11,"clone","nom::lib::std::iter","",122,{"inputs":[{"name":"self"}],"output":{"name":"fuse"}}],[11,"clone","nom::lib::std::option","",128,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"clone","nom::lib::std::str","",166,{"inputs":[{"name":"self"}],"output":{"name":"rsplit"}}],[11,"clone","","",112,{"inputs":[{"name":"self"}],"output":{"name":"rsplitterminator"}}],[11,"clone","nom::lib::std::prelude::v1::v1","",77,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","nom::lib::std::str","",125,{"inputs":[{"name":"self"}],"output":{"name":"rmatches"}}],[11,"clone","","",116,{"inputs":[{"name":"self"}],"output":{"name":"split"}}],[11,"clone","nom::lib::std::iter","",149,{"inputs":[{"name":"self"}],"output":{"name":"take"}}],[11,"clone","nom::lib::std::ops","",40,{"inputs":[{"name":"self"}],"output":{"name":"rangeto"}}],[11,"clone","nom::lib::std::slice","",170,{"inputs":[{"name":"self"}],"output":{"name":"split"}}],[11,"clone","","",144,{"inputs":[{"name":"self"}],"output":{"name":"rsplit"}}],[11,"clone","","",159,{"inputs":[{"name":"self"}],"output":{"name":"exactchunks"}}],[11,"clone","nom::lib::std::str","",169,{"inputs":[{"name":"self"}],"output":{"name":"linesany"}}],[11,"partial_cmp","nom::lib::std::cmp","",9,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",9,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"le","","",9,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"ge","","",9,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"gt","","",9,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"partial_cmp","nom::lib::std::prelude::v1::v1","",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"le","","",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"gt","","",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"ge","","",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"partial_cmp","nom::lib::std::cmp","",8,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"partial_cmp","nom::lib::std::ops","",73,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",73,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"le","","",73,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"gt","","",73,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"ge","","",73,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"partial_cmp","nom::lib::std::fmt","",183,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"partial_cmp","nom::lib::std::option","",184,{"inputs":[{"name":"self"},{"name":"noneerror"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"partial_cmp","nom::lib::std::prelude::v1::v1","",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"le","","",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"gt","","",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"ge","","",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"partial_cmp","nom::lib::std::mem","",174,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",174,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"le","","",174,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"gt","","",174,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"ge","","",174,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"next_back","nom::lib::std::iter","",110,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",110,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",110,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","nom::lib::std::slice","",150,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::iter","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",122,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",122,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","nom::lib::std::option","",151,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::iter","",121,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",154,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",154,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",154,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",122,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",122,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","nom::lib::std::str","",156,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","nom::lib::std::result","",135,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::iter","",118,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",165,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",165,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"g"}],"output":{"name":"r"}}],[11,"rfold","","",165,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"g"}],"output":{"name":"acc"}}],[11,"next_back","nom::lib::std::slice","",137,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::iter","",147,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",147,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",147,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","","",140,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::str","",162,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::slice","",168,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",168,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",168,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","","",159,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::ops","",109,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",109,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"next_back","nom::lib::std::str","",169,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","nom::lib::std::slice","",164,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",170,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::str","",114,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","","",166,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","nom::lib::std::iter","",153,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",153,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",153,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","nom::lib::std::str","",116,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","","",143,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","nom::lib::std::option","",158,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",128,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::iter","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",131,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"next_back","nom::lib::std::str","",157,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",117,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::result","",119,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::slice","",152,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",115,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::iter","",111,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",111,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",111,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"rfind","","",111,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"next_back","","",127,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::str","",112,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","nom::lib::std::iter","",145,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",145,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",145,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"next_back","nom::lib::std::str","",120,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"next_back","nom::lib::std::result","",129,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::str","",126,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"option"}}],[11,"rfind","","",126,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"next_back","","",148,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","nom::lib::std::slice","",144,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::iter","",163,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::slice","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",142,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","nom::lib::std::iter","",113,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",113,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",113,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"next_back","","",161,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",161,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",161,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","nom::lib::std::slice","",171,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::str","",125,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","nom::lib::std::ops","",67,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::iter","",138,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",138,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",138,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"cmp","nom::lib::std::cmp","",8,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::prelude::v1::v1","",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::option","",184,{"inputs":[{"name":"self"},{"name":"noneerror"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::ops","",73,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::cmp","",9,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::prelude::v1::v1","",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::mem","",174,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::fmt","",183,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"ordering"}}],[11,"from_iter","nom::lib::std::prelude::v1::v1","Takes each element in the [`Iterator`]: if it is [`None`], no further elements are taken, and the [`None`] is returned. Should no [`None`] occur, a container with the values of each `Option` is returned.",77,{"inputs":[{"name":"i"}],"output":{"name":"option"}}],[11,"from_iter","","Takes each element in the `Iterator`: if it is an `Err`, no further elements are taken, and the `Err` is returned. Should no `Err` occur, a container with the values of each `Result` is returned.",78,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"hash","nom::lib::std::option","",184,null],[11,"hash","nom::lib::std::prelude::v1::v1","",77,null],[11,"hash","nom::lib::std::mem","",174,null],[11,"hash","nom::lib::std::ops","",40,null],[11,"hash","","",109,null],[11,"hash","nom::lib::std::cmp","",8,null],[11,"hash","nom::lib::std::ops","",50,null],[11,"hash","","",108,null],[11,"hash","nom::lib::std::mem","",185,null],[11,"hash","nom::lib::std::ops","",67,null],[11,"hash","","",71,null],[11,"hash","","",57,null],[11,"hash","nom::lib::std::prelude::v1::v1","",78,null],[11,"hash","nom::lib::std::cmp","",9,null],[11,"hash","nom::lib::std::ops","",73,null],[11,"hash","nom::lib::std::fmt","",183,null],[11,"eq","nom::lib::std::ops","",73,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"ne","","",73,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::str","",178,{"inputs":[{"name":"self"},{"name":"utf8error"}],"output":{"name":"bool"}}],[11,"ne","","",178,{"inputs":[{"name":"self"},{"name":"utf8error"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::cmp","",9,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::ops","",71,{"inputs":[{"name":"self"},{"name":"bound"}],"output":{"name":"bool"}}],[11,"ne","","",71,{"inputs":[{"name":"self"},{"name":"bound"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::str","",176,{"inputs":[{"name":"self"},{"name":"parseboolerror"}],"output":{"name":"bool"}}],[11,"ne","","",176,{"inputs":[{"name":"self"},{"name":"parseboolerror"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::ops","",57,{"inputs":[{"name":"self"},{"name":"rangefrom"}],"output":{"name":"bool"}}],[11,"ne","","",57,{"inputs":[{"name":"self"},{"name":"rangefrom"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::prelude::v1::v1","",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"ne","","",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::ops","",67,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"ne","","",67,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"eq","","",108,{"inputs":[{"name":"self"},{"name":"rangefull"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::mem","",174,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"ne","","",174,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::ops","",50,{"inputs":[{"name":"self"},{"name":"rangetoinclusive"}],"output":{"name":"bool"}}],[11,"ne","","",50,{"inputs":[{"name":"self"},{"name":"rangetoinclusive"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::mem","",185,{"inputs":[{"name":"self"},{"name":"discriminant"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::str::pattern","",81,{"inputs":[{"name":"self"},{"name":"searchstep"}],"output":{"name":"bool"}}],[11,"ne","","",81,{"inputs":[{"name":"self"},{"name":"searchstep"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::fmt","",183,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::str::lossy","",84,{"inputs":[{"name":"self"},{"name":"utf8lossychunk"}],"output":{"name":"bool"}}],[11,"ne","","",84,{"inputs":[{"name":"self"},{"name":"utf8lossychunk"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::option","",184,{"inputs":[{"name":"self"},{"name":"noneerror"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::prelude::v1::v1","",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"ne","","",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::cmp","",8,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::ops","",109,{"inputs":[{"name":"self"},{"name":"rangeinclusive"}],"output":{"name":"bool"}}],[11,"ne","","",109,{"inputs":[{"name":"self"},{"name":"rangeinclusive"}],"output":{"name":"bool"}}],[11,"eq","","",40,{"inputs":[{"name":"self"},{"name":"rangeto"}],"output":{"name":"bool"}}],[11,"ne","","",40,{"inputs":[{"name":"self"},{"name":"rangeto"}],"output":{"name":"bool"}}],[11,"next_back","nom::lib::std::str::pattern","",181,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","",181,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject_back","","",181,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",179,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","",179,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",182,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","",182,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject_back","","",182,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",177,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","",177,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"get","nom::lib::std::ops","",67,null],[11,"get_mut","","",67,null],[11,"get_unchecked","","",67,null],[11,"get_unchecked_mut","","",67,null],[11,"index","","",67,null],[11,"index_mut","","",67,null],[11,"get","","",50,null],[11,"get_mut","","",50,null],[11,"get_unchecked","","",50,null],[11,"get_unchecked_mut","","",50,null],[11,"index","","",50,null],[11,"index_mut","","",50,null],[11,"get","","",40,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",40,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",40,null],[11,"get_unchecked_mut","","",40,null],[11,"index","","",40,null],[11,"index_mut","","",40,null],[11,"get","","",109,null],[11,"get_mut","","",109,null],[11,"get_unchecked","","",109,null],[11,"get_unchecked_mut","","",109,null],[11,"index","","",109,null],[11,"index_mut","","",109,null],[11,"get","","",108,null],[11,"get_mut","","",108,null],[11,"get_unchecked","","",108,null],[11,"get_unchecked_mut","","",108,null],[11,"index","","",108,null],[11,"index_mut","","",108,null],[11,"get","","",57,null],[11,"get_mut","","",57,null],[11,"get_unchecked","","",57,null],[11,"get_unchecked_mut","","",57,null],[11,"index","","",57,null],[11,"index_mut","","",57,null],[11,"get","","",50,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",50,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",50,null],[11,"get_unchecked_mut","","",50,null],[11,"index","","",50,null],[11,"index_mut","","",50,null],[11,"get","","",40,null],[11,"get_mut","","",40,null],[11,"get_unchecked","","",40,null],[11,"get_unchecked_mut","","",40,null],[11,"index","","",40,null],[11,"index_mut","","",40,null],[11,"get","","",108,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",108,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",108,null],[11,"get_unchecked_mut","","",108,null],[11,"index","","",108,null],[11,"index_mut","","",108,null],[11,"get","","",57,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",57,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",57,null],[11,"get_unchecked_mut","","",57,null],[11,"index","","",57,null],[11,"index_mut","","",57,null],[11,"get","","",109,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",109,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",109,null],[11,"get_unchecked_mut","","",109,null],[11,"index","","",109,null],[11,"index_mut","","",109,null],[11,"get","","",67,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",67,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",67,null],[11,"get_unchecked_mut","","",67,null],[11,"index","","",67,null],[11,"index_mut","","",67,null],[11,"sum","nom::lib::std::prelude::v1::v1","Takes each element in the `Iterator`: if it is an `Err`, no further elements are taken, and the `Err` is returned. Should no `Err` occur, the sum of all elements is returned.",78,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"len","nom::lib::std::iter","",113,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",113,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","",122,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",122,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","nom::lib::std::slice","",142,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","nom::lib::std::iter","",127,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"len","","",165,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",165,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","nom::lib::std::slice","",159,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","","",168,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","nom::lib::std::iter","",118,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"len","nom::lib::std::str","",126,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",126,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","nom::lib::std::iter","",111,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",111,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","nom::lib::std::slice","",164,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","nom::lib::std::iter","",138,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",138,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","",110,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",110,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","nom::lib::std::str","",178,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",176,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::mem","",173,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::fmt","",180,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str::lossy","",186,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::fmt","",183,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"haystack","nom::lib::std::str::pattern","",182,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"next","","",182,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","",182,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject","","",182,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"haystack","","",181,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"next","","",181,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","",181,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject","","",181,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"haystack","","",179,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"next","","",179,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","",179,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"haystack","","",177,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"next","","",177,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","",177,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"into_result","nom::lib::std::prelude::v1::v1","",77,{"inputs":[{"name":"self"}],"output":{"generics":["noneerror"],"name":"result"}}],[11,"from_ok","","",77,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[11,"from_error","","",77,{"inputs":[{"name":"noneerror"}],"output":{"name":"option"}}],[11,"into_result","","",78,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_ok","","",78,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[11,"from_error","","",78,{"inputs":[{"name":"e"}],"output":{"name":"result"}}],[11,"default","nom::lib::std::mem","",174,{"inputs":[],"output":{"name":"manuallydrop"}}],[11,"default","nom::lib::std::fmt","",183,{"inputs":[],"output":{"name":"error"}}],[11,"default","nom::lib::std::cmp","",9,{"inputs":[],"output":{"name":"reverse"}}],[11,"default","nom::lib::std::iter","",118,{"inputs":[],"output":{"name":"empty"}}],[11,"default","nom::lib::std::prelude::v1::v1","Returns [`None`].",77,{"inputs":[],"output":{"name":"option"}}],[11,"fmt","nom::lib::std::mem","",173,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::ops","",71,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str::pattern","",181,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::mem","",185,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::fmt","",180,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",145,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::mem","",173,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",160,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",116,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::cmp","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",133,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",130,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::cmp","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",138,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",172,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",122,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",140,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str::lossy","",84,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::result","",129,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",153,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str::pattern","",177,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",124,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",155,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",147,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",148,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",156,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",169,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::ops","",73,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::mem","",174,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::ops","",57,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",120,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",178,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",157,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",162,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",113,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",112,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",110,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::result","",119,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",134,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str::pattern","",179,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",132,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",159,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::prelude::v1::v1","",77,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",168,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",166,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::ops","",109,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",67,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",108,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",139,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::prelude::v1::v1","",78,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",118,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",165,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",146,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::option","",128,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",142,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",127,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",131,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str::pattern","",81,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",182,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::result","",135,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",152,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",143,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",114,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",144,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",111,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::fmt","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",137,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",126,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",164,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",154,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::fmt","",183,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",121,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",161,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",117,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",150,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",167,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",149,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",123,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",171,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::option","",158,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::ops","",50,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",176,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",125,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::option","",151,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str::lossy","",186,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::option","",184,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",115,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::iter","",163,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::slice","",170,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::ops","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::str","",136,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"into_iter","nom::lib::std::prelude::v1::v1","Returns a consuming iterator over the possibly contained value.",78,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"into_iter","","Returns a consuming iterator over the possibly contained value.",77,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"clone","nom::lib::std::vec","",187,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"clone","nom::lib::std::boxed","Returns a new box with a `clone()` of this box's contents.",107,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"clone_from","","Copies `source`'s contents into `self` without creating a new allocation.",107,null],[11,"clone","nom::lib::std::string","",188,{"inputs":[{"name":"self"}],"output":{"name":"parseerror"}}],[11,"clone","nom::lib::std::vec","",189,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"clone_from","","",189,null],[11,"clone","nom::lib::std::string","",190,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"clone_from","","",190,null],[11,"clone","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"clone","","",107,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"box"}}],[11,"to_string","nom::lib::std::string","",190,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"hash","","",190,null],[11,"hash","nom::lib::std::vec","",189,null],[11,"hash","nom::lib::std::boxed","",107,null],[11,"finish","","",107,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"write","","",107,null],[11,"write_u8","","",107,null],[11,"write_u16","","",107,null],[11,"write_u32","","",107,null],[11,"write_u64","","",107,null],[11,"write_u128","","",107,null],[11,"write_usize","","",107,null],[11,"write_i8","","",107,null],[11,"write_i16","","",107,null],[11,"write_i32","","",107,null],[11,"write_i64","","",107,null],[11,"write_i128","","",107,null],[11,"write_isize","","",107,null],[11,"deref_mut","","",191,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","nom::lib::std::string","",190,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"deref_mut","nom::lib::std::vec","",189,null],[11,"deref_mut","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"cmp","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"},{"name":"box"}],"output":{"name":"ordering"}}],[11,"cmp","nom::lib::std::vec","",189,{"inputs":[{"name":"self"},{"name":"vec"}],"output":{"name":"ordering"}}],[11,"into_iter","","Creates a consuming iterator, that is, one that moves each value out of the vector (from start to end). The vector cannot be used after calling this.",189,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"call_once","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"},{"name":"a"}],"output":{"name":"r"}}],[11,"call_once","","",107,{"inputs":[{"name":"self"},{"name":"a"}],"output":{"name":"r"}}],[11,"borrow_mut","","",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"borrow_mut","nom::lib::std::vec","",189,null],[11,"fmt","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",192,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",188,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",193,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",191,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"resume","","",107,{"inputs":[{"name":"self"}],"output":{"name":"generatorstate"}}],[11,"len","","",107,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",107,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","nom::lib::std::vec","",194,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","","",187,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_ref","nom::lib::std::string","",190,null],[11,"as_ref","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"as_ref","nom::lib::std::vec","",189,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"as_ref","","",189,null],[11,"as_ref","nom::lib::std::string","",190,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"deref","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref","nom::lib::std::string","",190,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"deref","nom::lib::std::boxed","",191,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref","nom::lib::std::vec","",189,null],[11,"as_mut","","",189,null],[11,"as_mut","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"as_mut","nom::lib::std::vec","",189,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"index_mut","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangeinclusive"}],"output":{"name":"str"}}],[11,"index_mut","","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"range"}],"output":{"name":"str"}}],[11,"index_mut","","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangefrom"}],"output":{"name":"str"}}],[11,"index_mut","nom::lib::std::vec","",189,null],[11,"index_mut","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangetoinclusive"}],"output":{"name":"str"}}],[11,"index_mut","","",190,{"inputs":[{"name":"self"},{"name":"rangefull"}],"output":{"name":"str"}}],[11,"index_mut","","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangeto"}],"output":{"name":"str"}}],[11,"default","nom::lib::std::vec","Creates an empty `Vec<T>`.",189,{"inputs":[],"output":{"name":"vec"}}],[11,"default","nom::lib::std::boxed","Creates a `Box<T>`, with the `Default` value for T.",107,{"inputs":[],"output":{"name":"box"}}],[11,"default","","",107,{"inputs":[],"output":{"name":"box"}}],[11,"default","","",107,{"inputs":[],"output":{"generics":["str"],"name":"box"}}],[11,"default","nom::lib::std::string","Creates an empty `String`.",190,{"inputs":[],"output":{"name":"string"}}],[11,"drop","nom::lib::std::vec","",189,null],[11,"drop","","",195,null],[11,"drop","","",194,null],[11,"drop","","",196,null],[11,"drop","","",187,null],[11,"drop","nom::lib::std::boxed","",107,null],[11,"drop","nom::lib::std::string","",197,null],[11,"fmt","nom::lib::std::boxed","",191,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::vec","",195,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::string","",192,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",197,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",188,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",193,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","nom::lib::std::vec","",196,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",194,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",189,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",187,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"from_iter","","",189,{"inputs":[{"name":"i"}],"output":{"name":"vec"}}],[11,"from_iter","nom::lib::std::string","",190,{"inputs":[{"name":"i"}],"output":{"name":"string"}}],[11,"from_iter","","",190,{"inputs":[{"name":"i"}],"output":{"name":"string"}}],[11,"from_iter","","",190,{"inputs":[{"name":"i"}],"output":{"name":"string"}}],[11,"from_iter","","",190,{"inputs":[{"name":"i"}],"output":{"name":"string"}}],[11,"from_iter","","",190,{"inputs":[{"name":"i"}],"output":{"name":"string"}}],[11,"fmt","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",191,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"index","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangeto"}],"output":{"name":"str"}}],[11,"index","","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangeinclusive"}],"output":{"name":"str"}}],[11,"index","","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangetoinclusive"}],"output":{"name":"str"}}],[11,"index","","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"rangefrom"}],"output":{"name":"str"}}],[11,"index","","",190,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"range"}],"output":{"name":"str"}}],[11,"index","nom::lib::std::vec","",189,null],[11,"index","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"rangefull"}],"output":{"name":"str"}}],[11,"borrow","nom::lib::std::vec","",189,null],[11,"borrow","nom::lib::std::string","",190,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"borrow","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"from_str","nom::lib::std::string","",190,{"inputs":[{"name":"str"}],"output":{"generics":["string","parseerror"],"name":"result"}}],[11,"eq","nom::lib::std::vec","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"ne","","",190,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::vec","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","nom::lib::std::string","",188,{"inputs":[{"name":"self"},{"name":"parseerror"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::vec","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"cow"}],"output":{"name":"bool"}}],[11,"ne","","",190,{"inputs":[{"name":"self"},{"name":"cow"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::vec","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"},{"name":"box"}],"output":{"name":"bool"}}],[11,"ne","","",107,{"inputs":[{"name":"self"},{"name":"box"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::vec","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,{"inputs":[{"name":"self"},{"name":"vec"}],"output":{"name":"bool"}}],[11,"ne","","",189,{"inputs":[{"name":"self"},{"name":"vec"}],"output":{"name":"bool"}}],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"ne","","",190,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::vec","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"ne","","",190,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"eq","nom::lib::std::vec","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"eq","","",189,null],[11,"ne","","",189,null],[11,"add_assign","nom::lib::std::string","",190,null],[11,"from","nom::lib::std::vec","",189,null],[11,"from","nom::lib::std::boxed","",191,{"inputs":[{"name":"box"}],"output":{"name":"pinbox"}}],[11,"from","","",107,{"inputs":[{"name":"pinbox"}],"output":{"name":"box"}}],[11,"from","","",107,{"inputs":[{"name":"string"}],"output":{"generics":["str"],"name":"box"}}],[11,"from","nom::lib::std::string","",190,{"inputs":[{"generics":["str"],"name":"cow"}],"output":{"name":"string"}}],[11,"from","nom::lib::std::vec","",189,null],[11,"from","nom::lib::std::boxed","",107,{"inputs":[{"name":"t"}],"output":{"name":"box"}}],[11,"from","nom::lib::std::string","",190,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[11,"from","nom::lib::std::boxed","",107,{"inputs":[{"name":"vec"}],"output":{"name":"box"}}],[11,"from","nom::lib::std::vec","",189,{"inputs":[{"name":"str"}],"output":{"generics":["u8"],"name":"vec"}}],[11,"from","nom::lib::std::string","",190,{"inputs":[{"generics":["str"],"name":"box"}],"output":{"name":"string"}}],[11,"from","nom::lib::std::boxed","",107,{"inputs":[{"generics":["str"],"name":"box"}],"output":{"name":"box"}}],[11,"from","","",107,{"inputs":[{"name":"str"}],"output":{"generics":["str"],"name":"box"}}],[11,"from","nom::lib::std::vec","",189,{"inputs":[{"name":"box"}],"output":{"name":"vec"}}],[11,"from","","",189,{"inputs":[{"name":"binaryheap"}],"output":{"name":"vec"}}],[11,"from","nom::lib::std::boxed","",107,null],[11,"from","nom::lib::std::vec","",189,{"inputs":[{"name":"vecdeque"}],"output":{"name":"vec"}}],[11,"from","","",189,{"inputs":[{"name":"cow"}],"output":{"name":"vec"}}],[11,"from","","",189,{"inputs":[{"name":"string"}],"output":{"generics":["u8"],"name":"vec"}}],[11,"write_str","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_char","","",190,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"generics":["error"],"name":"result"}}],[11,"extend","","",190,null],[11,"extend","nom::lib::std::vec","",189,null],[11,"extend","","",189,null],[11,"extend","nom::lib::std::string","",190,null],[11,"extend","","",190,null],[11,"extend","","",190,null],[11,"extend","","",190,null],[11,"next_back","nom::lib::std::vec","",187,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",194,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",195,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","nom::lib::std::string","",197,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"next_back","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","nom::lib::std::string","",197,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"size_hint","","",197,null],[11,"next","nom::lib::std::vec","",194,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",194,null],[11,"next","","",195,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",195,null],[11,"next","","",187,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",187,null],[11,"count","","",187,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"next","","",196,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",196,null],[11,"next","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",107,null],[11,"nth","","",107,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"partial_cmp","nom::lib::std::vec","",189,{"inputs":[{"name":"self"},{"name":"vec"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"partial_cmp","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",190,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"le","","",190,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"gt","","",190,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"ge","","",190,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"partial_cmp","nom::lib::std::boxed","",107,{"inputs":[{"name":"self"},{"name":"box"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",107,{"inputs":[{"name":"self"},{"name":"box"}],"output":{"name":"bool"}}],[11,"le","","",107,{"inputs":[{"name":"self"},{"name":"box"}],"output":{"name":"bool"}}],[11,"ge","","",107,{"inputs":[{"name":"self"},{"name":"box"}],"output":{"name":"bool"}}],[11,"gt","","",107,{"inputs":[{"name":"self"},{"name":"box"}],"output":{"name":"bool"}}],[11,"add","nom::lib::std::string","",190,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"string"}}],[11,"new","nom::lib::std::boxed","Allocate memory on the heap, move the data into it and pin it.",191,{"inputs":[{"name":"t"}],"output":{"name":"pinbox"}}],[11,"as_pin_mut","","Get a pinned reference to the data in this PinBox.",191,{"inputs":[{"name":"self"}],"output":{"name":"pinmut"}}],[11,"get_mut","","Get a mutable reference to the data inside this PinBox.",191,{"inputs":[{"name":"pinbox"}],"output":{"name":"t"}}],[11,"unpin","","Convert this PinBox into an unpinned Box.",191,{"inputs":[{"name":"pinbox"}],"output":{"name":"box"}}],[11,"new","nom::lib::std::string","Creates a new empty `String`.",190,{"inputs":[],"output":{"name":"string"}}],[11,"with_capacity","","Creates a new empty `String` with a particular capacity.",190,{"inputs":[{"name":"usize"}],"output":{"name":"string"}}],[11,"from_utf8","","Converts a vector of bytes to a `String`.",190,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"generics":["string","fromutf8error"],"name":"result"}}],[11,"from_utf8_lossy","","Converts a slice of bytes to a string, including invalid characters.",190,null],[11,"from_utf16","","Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`] if `v` contains any invalid data.",190,null],[11,"from_utf16_lossy","","Decode a UTF-16 encoded slice `v` into a `String`, replacing invalid data with the replacement character (U+FFFD).",190,null],[11,"from_raw_parts","","Creates a new `String` from a length, capacity, and pointer.",190,null],[11,"from_utf8_unchecked","","Converts a vector of bytes to a `String` without checking that the string contains valid UTF-8.",190,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"string"}}],[11,"into_bytes","","Converts a `String` into a byte vector.",190,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"vec"}}],[11,"as_str","","Extracts a string slice containing the entire string.",190,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"as_mut_str","","Converts a `String` into a mutable string slice.",190,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"push_str","","Appends a given string slice onto the end of this `String`.",190,null],[11,"capacity","","Returns this `String`'s capacity, in bytes.",190,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"reserve","","Ensures that this `String`'s capacity is at least `additional` bytes larger than its length.",190,null],[11,"reserve_exact","","Ensures that this `String`'s capacity is `additional` bytes larger than its length.",190,null],[11,"try_reserve","","Tries to reserve capacity for at least `additional` more elements to be inserted in the given `String`. The collection may reserve more space to avoid frequent reallocations. After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if capacity is already sufficient.",190,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["collectionallocerr"],"name":"result"}}],[11,"try_reserve_exact","","Tries to reserves the minimum capacity for exactly `additional` more elements to be inserted in the given `String`. After calling `reserve_exact`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if the capacity is already sufficient.",190,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["collectionallocerr"],"name":"result"}}],[11,"shrink_to_fit","","Shrinks the capacity of this `String` to match its length.",190,null],[11,"shrink_to","","Shrinks the capacity of this `String` with a lower bound.",190,null],[11,"push","","Appends the given [`char`] to the end of this `String`.",190,null],[11,"as_bytes","","Returns a byte slice of this `String`'s contents.",190,null],[11,"truncate","","Shortens this `String` to the specified length.",190,null],[11,"pop","","Removes the last character from the string buffer and returns it.",190,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"remove","","Removes a [`char`] from this `String` at a byte position and returns it.",190,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"char"}}],[11,"retain","","Retains only the characters specified by the predicate.",190,null],[11,"insert","","Inserts a character into this `String` at a byte position.",190,null],[11,"insert_str","","Inserts a string slice into this `String` at a byte position.",190,null],[11,"as_mut_vec","","Returns a mutable reference to the contents of this `String`.",190,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"len","","Returns the length of this `String`, in bytes.",190,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns `true` if this `String` has a length of zero.",190,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"split_off","","Splits the string into two at the given index.",190,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"string"}}],[11,"clear","","Truncates this `String`, removing all contents.",190,null],[11,"drain","","Creates a draining iterator that removes the specified range in the string and yields the removed chars.",190,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"drain"}}],[11,"replace_range","","Removes the specified range in the string, and replaces it with the given string. The given string doesn't need to be the same length as the range.",190,null],[11,"into_boxed_str","","Converts this `String` into a [`Box`]`<`[`str`]`>`.",190,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"box"}}],[11,"as_bytes","","Returns a slice of [`u8`]s bytes that were attempted to convert to a `String`.",193,null],[11,"into_bytes","","Returns the bytes that were attempted to convert to a `String`.",193,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"vec"}}],[11,"utf8_error","","Fetch a `Utf8Error` to get more details about the conversion failure.",193,{"inputs":[{"name":"self"}],"output":{"name":"utf8error"}}],[11,"new","nom::lib::std::vec","Constructs a new, empty `Vec<T>`.",189,{"inputs":[],"output":{"name":"vec"}}],[11,"with_capacity","","Constructs a new, empty `Vec<T>` with the specified capacity.",189,{"inputs":[{"name":"usize"}],"output":{"name":"vec"}}],[11,"from_raw_parts","","Creates a `Vec<T>` directly from the raw components of another vector.",189,null],[11,"capacity","","Returns the number of elements the vector can hold without reallocating.",189,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"reserve","","Reserves capacity for at least `additional` more elements to be inserted in the given `Vec<T>`. The collection may reserve more space to avoid frequent reallocations. After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if capacity is already sufficient.",189,null],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more elements to be inserted in the given `Vec<T>`. After calling `reserve_exact`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if the capacity is already sufficient.",189,null],[11,"try_reserve","","Tries to reserve capacity for at least `additional` more elements to be inserted in the given `Vec<T>`. The collection may reserve more space to avoid frequent reallocations. After calling `reserve`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if capacity is already sufficient.",189,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["collectionallocerr"],"name":"result"}}],[11,"try_reserve_exact","","Tries to reserves the minimum capacity for exactly `additional` more elements to be inserted in the given `Vec<T>`. After calling `reserve_exact`, capacity will be greater than or equal to `self.len() + additional`. Does nothing if the capacity is already sufficient.",189,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["collectionallocerr"],"name":"result"}}],[11,"shrink_to_fit","","Shrinks the capacity of the vector as much as possible.",189,null],[11,"shrink_to","","Shrinks the capacity of the vector with a lower bound.",189,null],[11,"into_boxed_slice","","Converts the vector into [`Box<[T]>`][owned slice].",189,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"truncate","","Shortens the vector, keeping the first `len` elements and dropping the rest.",189,null],[11,"as_slice","","Extracts a slice containing the entire vector.",189,null],[11,"as_mut_slice","","Extracts a mutable slice of the entire vector.",189,null],[11,"set_len","","Sets the length of a vector.",189,null],[11,"swap_remove","","Removes an element from the vector and returns it.",189,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"insert","","Inserts an element at position `index` within the vector, shifting all elements after it to the right.",189,null],[11,"remove","","Removes and returns the element at position `index` within the vector, shifting all elements after it to the left.",189,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"retain","","Retains only the elements specified by the predicate.",189,null],[11,"dedup_by_key","","Removes all but the first of consecutive elements in the vector that resolve to the same key.",189,null],[11,"dedup_by","","Removes all but the first of consecutive elements in the vector satisfying a given equality relation.",189,null],[11,"push","","Appends an element to the back of a collection.",189,null],[11,"pop","","Removes the last element from a vector and returns it, or [`None`] if it is empty.",189,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"append","","Moves all the elements of `other` into `Self`, leaving `other` empty.",189,null],[11,"drain","","Creates a draining iterator that removes the specified range in the vector and yields the removed items.",189,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"drain"}}],[11,"clear","","Clears the vector, removing all values.",189,null],[11,"len","","Returns the number of elements in the vector, also referred to as its 'length'.",189,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns `true` if the vector contains no elements.",189,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"split_off","","Splits the collection into two at the given index.",189,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"vec"}}],[11,"resize_with","","Resizes the `Vec` in-place so that `len` is equal to `new_len`.",189,null],[11,"resize","","Resizes the `Vec` in-place so that `len` is equal to `new_len`.",189,null],[11,"extend_from_slice","","Clones and appends all elements in a slice to the `Vec`.",189,null],[11,"resize_default","","Resizes the `Vec` in-place so that `len` is equal to `new_len`.",189,null],[11,"dedup","","Removes consecutive repeated elements in the vector.",189,null],[11,"remove_item","","Removes the first instance of `item` from the vector if the item exists.",189,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[11,"splice","","Creates a splicing iterator that replaces the specified range in the vector with the given `replace_with` iterator and yields the removed items. `replace_with` does not need to be the same length as `range`.",189,{"inputs":[{"name":"self"},{"name":"r"},{"name":"i"}],"output":{"name":"splice"}}],[11,"drain_filter","","Creates an iterator which uses a closure to determine if an element should be removed.",189,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"drainfilter"}}],[11,"as_slice","","Returns the remaining items of this iterator as a slice.",187,null],[11,"as_mut_slice","","Returns the remaining items of this iterator as a mutable slice.",187,null],[11,"reverse","nom::lib::std::cmp","Reverses the `Ordering`.",8,{"inputs":[{"name":"self"}],"output":{"name":"ordering"}}],[11,"then","","Chains two orderings.",8,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"ordering"}}],[11,"then_with","","Chains the ordering with the given function.",8,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"ordering"}}],[11,"pad_integral","nom::lib::std::fmt","Performs the correct padding for an integer which has already been emitted into a str. The str should not contain the sign for the integer, that will be added by this method.",175,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"str"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"pad","","This function takes a string slice and emits it to the internal buffer after applying the relevant formatting flags specified. The flags recognized for generic strings are:",175,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_str","","Writes some data to the underlying buffer contained within this formatter.",175,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_fmt","","Writes some formatted information into this instance",175,{"inputs":[{"name":"self"},{"name":"arguments"}],"output":{"generics":["error"],"name":"result"}}],[11,"flags","","Flags for formatting",175,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"fill","","Character used as 'fill' whenever there is alignment",175,{"inputs":[{"name":"self"}],"output":{"name":"char"}}],[11,"align","","Flag indicating what form of alignment was requested",175,{"inputs":[{"name":"self"}],"output":{"name":"alignment"}}],[11,"width","","Optionally specified integer width that the output should be.",175,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"precision","","Optionally specified precision for numeric types.",175,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"sign_plus","","Determines if the `+` flag was specified.",175,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"sign_minus","","Determines if the `-` flag was specified.",175,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"alternate","","Determines if the `#` flag was specified.",175,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"sign_aware_zero_pad","","Determines if the `0` flag was specified.",175,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"debug_struct","","Creates a [`DebugStruct`] builder designed to assist with creation of [`fmt::Debug`] implementations for structs.",175,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"debugstruct"}}],[11,"debug_tuple","","Creates a `DebugTuple` builder designed to assist with creation of `fmt::Debug` implementations for tuple structs.",175,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"debugtuple"}}],[11,"debug_list","","Creates a `DebugList` builder designed to assist with creation of `fmt::Debug` implementations for list-like structures.",175,{"inputs":[{"name":"self"}],"output":{"name":"debuglist"}}],[11,"debug_set","","Creates a `DebugSet` builder designed to assist with creation of `fmt::Debug` implementations for set-like structures.",175,{"inputs":[{"name":"self"}],"output":{"name":"debugset"}}],[11,"debug_map","","Creates a `DebugMap` builder designed to assist with creation of `fmt::Debug` implementations for map-like structures.",175,{"inputs":[{"name":"self"}],"output":{"name":"debugmap"}}],[11,"entry","","Adds a new entry to the map output.",198,{"inputs":[{"name":"self"},{"name":"debug"},{"name":"debug"}],"output":{"name":"debugmap"}}],[11,"entries","","Adds the contents of an iterator of entries to the map output.",198,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"debugmap"}}],[11,"finish","","Finishes output and returns any error encountered.",198,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"field","","Adds a new field to the generated struct output.",199,{"inputs":[{"name":"self"},{"name":"str"},{"name":"debug"}],"output":{"name":"debugstruct"}}],[11,"finish","","Finishes output and returns any error encountered.",199,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"entry","","Adds a new entry to the list output.",200,{"inputs":[{"name":"self"},{"name":"debug"}],"output":{"name":"debuglist"}}],[11,"entries","","Adds the contents of an iterator of entries to the list output.",200,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"debuglist"}}],[11,"finish","","Finishes output and returns any error encountered.",200,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"entry","","Adds a new entry to the set output.",201,{"inputs":[{"name":"self"},{"name":"debug"}],"output":{"name":"debugset"}}],[11,"entries","","Adds the contents of an iterator of entries to the set output.",201,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"debugset"}}],[11,"finish","","Finishes output and returns any error encountered.",201,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"field","","Adds a new field to the generated tuple struct output.",202,{"inputs":[{"name":"self"},{"name":"debug"}],"output":{"name":"debugtuple"}}],[11,"finish","","Finishes output and returns any error encountered.",202,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"peek","nom::lib::std::iter","Returns a reference to the next() value without advancing the iterator.",133,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","nom::lib::std::mem","Wrap a value to be manually dropped.",174,{"inputs":[{"name":"t"}],"output":{"name":"manuallydrop"}}],[11,"into_inner","","Extract the value from the ManuallyDrop container.",174,{"inputs":[{"name":"manuallydrop"}],"output":{"name":"t"}}],[11,"drop","","Manually drops the contained value.",174,null],[11,"new","","Construct a new `PinMut` around a reference to some data of a type that implements `Unpin`.",173,{"inputs":[{"name":"t"}],"output":{"name":"pinmut"}}],[11,"new_unchecked","","Construct a new `PinMut` around a reference to some data of a type that may or may not implement `Unpin`.",173,{"inputs":[{"name":"t"}],"output":{"name":"pinmut"}}],[11,"reborrow","","Reborrow a `PinMut` for a shorter lifetime.",173,{"inputs":[{"name":"self"}],"output":{"name":"pinmut"}}],[11,"get_mut","","Get a mutable reference to the data inside of this `PinMut`.",173,{"inputs":[{"name":"pinmut"}],"output":{"name":"t"}}],[11,"map","","Construct a new pin by mapping the interior value.",173,{"inputs":[{"name":"pinmut"},{"name":"f"}],"output":{"name":"pinmut"}}],[11,"contains","nom::lib::std::ops","Returns `true` if `item` is contained in the range.",40,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",50,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",57,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"bool"}}],[11,"new","","Creates a new inclusive range. Equivalent to writing `start..=end`.",109,{"inputs":[{"name":"idx"},{"name":"idx"}],"output":{"name":"rangeinclusive"}}],[11,"start","","Returns the lower bound of the range (inclusive).",109,{"inputs":[{"name":"self"}],"output":{"name":"idx"}}],[11,"end","","Returns the upper bound of the range (inclusive).",109,{"inputs":[{"name":"self"}],"output":{"name":"idx"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",109,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"bool"}}],[11,"is_empty","","Returns `true` if the range contains no items.",109,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",67,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"bool"}}],[11,"is_empty","","Returns `true` if the range contains no items.",67,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_some","nom::lib::std::prelude::v1::v1","Returns `true` if the option is a [`Some`] value.",77,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_none","","Returns `true` if the option is a [`None`] value.",77,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_ref","","Converts from `Option<T>` to `Option<&T>`.",77,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_mut","","Converts from `Option<T>` to `Option<&mut T>`.",77,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"expect","","Unwraps an option, yielding the content of a [`Some`].",77,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"t"}}],[11,"unwrap","","Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].",77,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"unwrap_or","","Returns the contained value or a default.",77,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"t"}}],[11,"unwrap_or_else","","Returns the contained value or computes it from a closure.",77,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"t"}}],[11,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.",77,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"map_or","","Applies a function to the contained value (if any), or returns the provided default (if not).",77,{"inputs":[{"name":"self"},{"name":"u"},{"name":"f"}],"output":{"name":"u"}}],[11,"map_or_else","","Applies a function to the contained value (if any), or computes a default (if not).",77,{"inputs":[{"name":"self"},{"name":"d"},{"name":"f"}],"output":{"name":"u"}}],[11,"ok_or","","Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to [`Ok(v)`] and [`None`] to [`Err(err)`].",77,{"inputs":[{"name":"self"},{"name":"e"}],"output":{"name":"result"}}],[11,"ok_or_else","","Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to [`Ok(v)`] and [`None`] to [`Err(err())`].",77,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"iter","","Returns an iterator over the possibly contained value.",77,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",77,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"and","","Returns [`None`] if the option is [`None`], otherwise returns `optb`.",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"option"}}],[11,"and_then","","Returns [`None`] if the option is [`None`], otherwise calls `f` with the wrapped value and returns the result.",77,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"filter","","Returns `None` if the option is `None`, otherwise calls `predicate` with the wrapped value and returns:",77,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"or","","Returns the option if it contains a value, otherwise returns `optb`.",77,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"option"}}],[11,"or_else","","Returns the option if it contains a value, otherwise calls `f` and returns the result.",77,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"get_or_insert","","Inserts `v` into the option if it is [`None`], then returns a mutable reference to the contained value.",77,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"t"}}],[11,"get_or_insert_with","","Inserts a value computed from `f` into the option if it is [`None`], then returns a mutable reference to the contained value.",77,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"t"}}],[11,"take","","Takes the value out of the option, leaving a [`None`] in its place.",77,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"cloned","","Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the option.",77,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"cloned","","Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the option.",77,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"unwrap_or_default","","Returns the contained value or a default",77,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"transpose","","Transposes an `Option` of a `Result` into a `Result` of an `Option`.",77,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"result"}}],[11,"is_ok","","Returns `true` if the result is [`Ok`].",78,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_err","","Returns `true` if the result is [`Err`].",78,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"ok","","Converts from `Result<T, E>` to [`Option<T>`].",78,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"err","","Converts from `Result<T, E>` to [`Option<E>`].",78,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_ref","","Converts from `Result<T, E>` to `Result<&T, &E>`.",78,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"as_mut","","Converts from `Result<T, E>` to `Result<&mut T, &mut E>`.",78,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"map","","Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained [`Ok`] value, leaving an [`Err`] value untouched.",78,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"map_err","","Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained [`Err`] value, leaving an [`Ok`] value untouched.",78,{"inputs":[{"name":"self"},{"name":"o"}],"output":{"name":"result"}}],[11,"iter","","Returns an iterator over the possibly contained value.",78,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",78,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"and","","Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"result"}}],[11,"and_then","","Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.",78,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"or","","Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.",78,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"result"}}],[11,"or_else","","Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.",78,{"inputs":[{"name":"self"},{"name":"o"}],"output":{"name":"result"}}],[11,"unwrap_or","","Unwraps a result, yielding the content of an [`Ok`]. Else, it returns `optb`.",78,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"t"}}],[11,"unwrap_or_else","","Unwraps a result, yielding the content of an [`Ok`]. If the value is an [`Err`] then it calls `op` with its value.",78,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"t"}}],[11,"unwrap","","Unwraps a result, yielding the content of an [`Ok`].",78,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"expect","","Unwraps a result, yielding the content of an [`Ok`].",78,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"t"}}],[11,"unwrap_err","","Unwraps a result, yielding the content of an [`Err`].",78,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"expect_err","","Unwraps a result, yielding the content of an [`Err`].",78,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"e"}}],[11,"unwrap_or_default","","Returns the contained value or a default",78,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"transpose","","Transposes a `Result` of an `Option` into an `Option` of a `Result`.",78,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"option"}}],[11,"as_slice","nom::lib::std::slice","View the underlying data as a subslice of the original data.",142,null],[11,"into_slice","","View the underlying data as a subslice of the original data.",168,null],[11,"from_str","nom::lib::std::str::lossy","",186,{"inputs":[{"name":"str"}],"output":{"name":"utf8lossy"}}],[11,"from_bytes","","",186,null],[11,"chunks","","",186,{"inputs":[{"name":"self"}],"output":{"name":"utf8lossychunksiter"}}],[11,"valid_up_to","nom::lib::std::str","Returns the index in the given string up to which valid UTF-8 was verified.",178,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"error_len","","Provide more information about the failure:",178,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"as_str","","View the underlying data as a subslice of the original data.",120,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"as_str","","View the underlying data as a subslice of the original data.",162,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"split_at_position","nom::types","",90,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["u32"],"name":"iresult"}}],[11,"split_at_position1","","",90,{"inputs":[{"name":"self"},{"name":"p"},{"generics":["u32"],"name":"errorkind"}],"output":{"generics":["u32"],"name":"iresult"}}],[11,"split_at_position","","",89,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["u32"],"name":"iresult"}}],[11,"split_at_position1","","",89,{"inputs":[{"name":"self"},{"name":"p"},{"generics":["u32"],"name":"errorkind"}],"output":{"generics":["u32"],"name":"iresult"}}]],"paths":[[4,"CompareResult"],[4,"ErrorKind"],[4,"Needed"],[4,"Err"],[4,"Endianness"],[8,"FnBox"],[8,"ToString"],[8,"PartialEq"],[4,"Ordering"],[3,"Reverse"],[8,"Ord"],[8,"PartialOrd"],[8,"AsRef"],[8,"AsMut"],[8,"Into"],[8,"From"],[8,"TryInto"],[8,"TryFrom"],[4,"Alignment"],[8,"Write"],[8,"Debug"],[8,"Display"],[8,"Octal"],[8,"Binary"],[8,"LowerHex"],[8,"UpperHex"],[8,"Pointer"],[8,"LowerExp"],[8,"UpperExp"],[8,"Extend"],[8,"Sum"],[8,"Iterator"],[8,"IntoIterator"],[8,"Step"],[8,"FromIterator"],[8,"ExactSizeIterator"],[8,"DoubleEndedIterator"],[8,"Product"],[8,"Drop"],[8,"RangeBounds"],[3,"RangeTo"],[8,"BitAndAssign"],[8,"Mul"],[8,"Try"],[8,"Index"],[8,"Generator"],[8,"DerefMut"],[8,"FnOnce"],[8,"BitOr"],[8,"RemAssign"],[3,"RangeToInclusive"],[8,"BitAnd"],[8,"ShlAssign"],[8,"Neg"],[8,"ShrAssign"],[8,"DivAssign"],[8,"Add"],[3,"RangeFrom"],[8,"Shl"],[8,"Deref"],[8,"MulAssign"],[8,"Fn"],[8,"SubAssign"],[8,"BitXor"],[8,"FnMut"],[8,"Rem"],[8,"Shr"],[3,"Range"],[8,"BitXorAssign"],[8,"Not"],[8,"AddAssign"],[4,"Bound"],[8,"Div"],[4,"GeneratorState"],[8,"IndexMut"],[8,"BitOrAssign"],[8,"Sub"],[4,"Option"],[4,"Result"],[8,"SliceIndex"],[8,"Pattern"],[4,"SearchStep"],[8,"Searcher"],[8,"ReverseSearcher"],[3,"Utf8LossyChunk"],[8,"FromStr"],[8,"Clone"],[8,"Default"],[4,"Context"],[3,"CompleteStr"],[3,"CompleteByteSlice"],[3,"Input"],[8,"InputLength"],[8,"Offset"],[8,"AsBytes"],[8,"AsChar"],[8,"InputIter"],[8,"InputTake"],[8,"InputTakeAtPosition"],[8,"Compare"],[8,"FindToken"],[8,"FindSubstring"],[8,"ParseTo"],[8,"Slice"],[8,"AtEof"],[8,"ExtendInto"],[8,"Convert"],[3,"Box"],[3,"RangeFull"],[3,"RangeInclusive"],[3,"Inspect"],[3,"Rev"],[3,"RSplitTerminator"],[3,"Cloned"],[3,"Lines"],[3,"Windows"],[3,"Split"],[3,"RMatchIndices"],[3,"Empty"],[3,"IterMut"],[3,"Chars"],[3,"RepeatWith"],[3,"Fuse"],[3,"Scan"],[3,"RSplitN"],[3,"RMatches"],[3,"Bytes"],[3,"Once"],[3,"Iter"],[3,"Iter"],[3,"StepBy"],[3,"Skip"],[3,"SplitN"],[3,"Peekable"],[3,"SkipWhile"],[3,"IntoIter"],[3,"EncodeUtf16"],[3,"RSplitMut"],[3,"Enumerate"],[3,"RSplitNMut"],[3,"Repeat"],[3,"Utf8LossyChunksIter"],[3,"Iter"],[3,"Matches"],[3,"RSplit"],[3,"Chain"],[3,"SplitN"],[3,"Filter"],[3,"SplitTerminator"],[3,"Take"],[3,"SplitMut"],[3,"IterMut"],[3,"ChunksMut"],[3,"FlatMap"],[3,"Flatten"],[3,"SplitNMut"],[3,"SplitWhitespace"],[3,"MatchIndices"],[3,"IntoIter"],[3,"ExactChunks"],[3,"RSplitN"],[3,"FilterMap"],[3,"CharIndices"],[3,"Zip"],[3,"ExactChunksMut"],[3,"Map"],[3,"RSplit"],[3,"Cycle"],[3,"IterMut"],[3,"LinesAny"],[3,"Split"],[3,"Chunks"],[3,"TakeWhile"],[3,"PinMut"],[19,"ManuallyDrop"],[3,"Formatter"],[3,"ParseBoolError"],[3,"StrSearcher"],[3,"Utf8Error"],[3,"CharSearcher"],[3,"Arguments"],[3,"CharSliceSearcher"],[3,"CharPredicateSearcher"],[3,"Error"],[3,"NoneError"],[3,"Discriminant"],[3,"Utf8Lossy"],[3,"IntoIter"],[4,"ParseError"],[3,"Vec"],[3,"String"],[3,"PinBox"],[3,"FromUtf16Error"],[3,"FromUtf8Error"],[3,"Drain"],[3,"Splice"],[3,"DrainFilter"],[3,"Drain"],[3,"DebugMap"],[3,"DebugStruct"],[3,"DebugList"],[3,"DebugSet"],[3,"DebugTuple"]]};
initSearch(searchIndex);
